<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Arqueiro Lend√°rio</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      margin: 0;
      overflow: hidden;
      color: white;
      font-family: 'Press Start 2P', cursive;
      text-align: center;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      user-select: none;
    }
    
    .hell-mode {
      background: linear-gradient(135deg, #290a0a, #631a1a, #3e0e0e) !important;
    }
    
    canvas {
      display: none;
      background: #111;
      margin: 20px auto;
      border-radius: 10px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      border: 2px solid #00ffff;
    }
    
    .hell-canvas {
      box-shadow: 0 0 30px rgba(255, 50, 50, 0.5) !important;
      border: 2px solid #ff0000 !important;
    }
    
    #menu {
      background: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      max-width: 780px;
      margin: 0 auto;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.4);
      border: 3px solid #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 200, 0.5);
    }
    
    h1 {
      color: #00ff88;
      text-shadow: 0 0 15px rgba(0, 255, 150, 0.7);
      margin-bottom: 30px;
      font-size: 3em;
      font-family: 'Bangers', cursive;
      letter-spacing: 3px;
    }
    
    .power-options {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 25px;
      margin-bottom: 30px;
    }
    
    .power-option {
      background: rgba(20, 20, 40, 0.9);
      padding: 20px;
      border-radius: 15px;
      width: 220px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .power-option:hover {
      transform: translateY(-8px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
      border-color: #00ff88;
    }
    
    .power-option.selected {
      border-color: #00ff88;
      background: rgba(0, 255, 150, 0.15);
      box-shadow: 0 0 20px rgba(0, 255, 150, 0.3);
    }
    
    .power-option .character-icon {
      font-size: 50px;
      margin-bottom: 15px;
      filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.7));
    }
    
    .power-option div:not(.character-icon) {
      margin: 5px 0;
    }
    
    .power-description {
      font-size: 0.7em;
      color: #aaa;
      margin-top: 10px;
      line-height: 1.4;
      font-family: 'Arial', sans-serif;
    }
    
    button {
      background: linear-gradient(135deg, #00ff88, #007544);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 1.3em;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      margin-top: 20px;
      font-family: 'Press Start 2P', cursive;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      letter-spacing: 1px;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      background: linear-gradient(135deg, #00e67b, #00633a);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    .hell-button {
      background: linear-gradient(135deg, #ff0000, #7a0000) !important;
    }
    
    .hell-button:hover {
      background: linear-gradient(135deg, #e60000, #5a0000) !important;
    }
    
    #victory-screen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
    }
    
    #victory-screen h1 {
      color: gold;
      font-size: 5em;
      text-shadow: 0 0 30px gold;
      margin-bottom: 30px;
      animation: pulse 2s infinite;
      font-family: 'Bangers', cursive;
    }
    
    #victory-screen p {
      font-size: 1.5em;
      margin-bottom: 40px;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 150, 0.5);
    }
    
    #hell-victory-screen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
    }
    
    #hell-victory-screen h1 {
      color: #ff0000;
      font-size: 4em;
      text-shadow: 0 0 20px #ff0000;
      margin-bottom: 30px;
      animation: pulse 2s infinite;
      font-family: 'Bangers', cursive;
    }
    
    #hell-victory-screen p {
      font-size: 1.5em;
      margin-bottom: 40px;
      color: #ff5555;
      text-shadow: 0 0 10px rgba(255, 50, 50, 0.5);
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    #wave-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 12px 25px;
      border-radius: 25px;
      font-size: 1.3em;
      border: 2px solid #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 150, 0.3);
      text-shadow: 0 0 5px rgba(0, 255, 150, 0.5);
    }
    
    .hell-wave {
      border: 2px solid #ff0000 !important;
      box-shadow: 0 0 15px rgba(255, 50, 50, 0.5) !important;
      text-shadow: 0 0 5px rgba(255, 50, 50, 0.7) !important;
    }
    
    #controls {
      margin-top: 30px;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid #00ffff;
    }
    
    #controls h3 {
      color: #00ffff;
      margin-bottom: 10px;
      font-size: 1em;
    }
    
    #controls p {
      font-size: 0.7em;
      margin: 5px 0;
      font-family: 'Arial', sans-serif;
    }
    
    .particle {
      position: absolute;
      background: white;
      border-radius: 50%;
      pointer-events: none;
    }
    
    .hell-particle {
      background: #ff5555 !important;
    }
    
    #loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0f0c29;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    #loading-bar {
      width: 300px;
      height: 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      margin-top: 20px;
      overflow: hidden;
      border: 2px solid #00ff88;
    }
    
    #loading-progress {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00ff88, #00ffff);
      transition: width 0.3s;
    }
    
    #loading-text {
      margin-top: 15px;
      color: #00ff88;
      font-size: 0.8em;
    }
    
    .lava-patch {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
    }
    
    .dark-patch {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="loading-screen">
    <h1 style="color: #00ff88; font-size: 3em;">ARQUEIRO LEND√ÅRIO</h1>
    <div id="loading-bar">
      <div id="loading-progress"></div>
    </div>
    <div id="loading-text">Carregando recursos...</div>
  </div>

  <div id="menu">
    <h1>ARQUEIRO LEND√ÅRIO</h1>
    <div class="power-options">
      <div class="power-option selected" onclick="selectPower('explosive')">
       <div class="character-icon">üí•</div>
        <div>EXPLOSIVO</div>
        <div class="power-description">Cria uma explos√£o poderosa em volta de si que causa dano em √°rea!</div>
      </div>
      <div class="power-option" onclick="selectPower('multi')">
        <div class="character-icon">üèπ</div>
        <div>CHUVA DE FLECHAS</div>
        <div class="power-description">Dispara 14 flechas de uma vez, atingindo todos os inimigos a sua frente!</div>
      </div>
      <div class="power-option" onclick="selectPower('freeze')">
        <div class="character-icon">‚ùÑÔ∏è</div>
        <div>CONGELAMENTO</div>
        <div class="power-description">Deixa seus inimigos com um resfriado, todos eles ficam muito lentos por alguns segundos!</div>
      </div>
      <div class="power-option" onclick="selectPower('lightning')">
       <div class="character-icon">‚ö°</div>
        <div>REL√ÇMPAGO</div>
        <div class="power-description">Eletrocuta at√© 12 inimigos pr√≥ximos, deixando-os paralisados por alguns instantes!</div>
      </div>
      <div class="power-option" onclick="selectPower('shield')">
        <div class="character-icon">üî∞</div>
        <div>ESCUDO C√ìSMICO</div>
        <div class="power-description">Cria um escudo de invencibilidade tempor√°rio!</div>
      </div>
      <div class="power-option" onclick="selectPower('meteor')">
        <div class="character-icon">‚òÑÔ∏è</div>
        <div>ENCOMENDA DOS C√âUS</div>
        <div class="power-description">Meteoros caem dos c√©us e esmagam seus inimigos, deixando o ch√£o em chamas!</div>
      </div>
    </div>
    <button onclick="startGame()">COME√áAR JOGO</button>
    
    <div id="controls">
      <h3>CONTROLES</h3>
      <p>WASD - Movimento | Mouse - Mirar e Atirar | E - Habilidade Especial | Q - Dash</p>
      <p>Colete power-ups, Mate Inimigos e Derrote os 3 Reis da Morte!</p>
    </div>
  </div>
  
  <canvas id="gameCanvas" width="1000" height="750"></canvas>
  
  <div id="wave-display" style="display: none;">WAVE: 1</div>
  
  <div id="victory-screen">
    <h1>VIT√ìRIA!</h1>
    <p>Voc√™ Provou ser Digno da Coroa, Agora Teste Outros Poderes!</p>
    <button onclick="backToMenu()">JOGAR NOVAMENTE</button>
    <button class="hell-button" onclick="startHellMode()">‚ò†Ô∏èPROVE SEU VALOR CONTRA O INFERNO‚ò†Ô∏è</button>
  </div>
  
  <div id="hell-victory-screen">
    <h1>VIT√ìRIA LEND√ÅRIA!</h1>
    <p>Voc√™ Provou Ser Sobre Humano e Consquistou as For√ßas da Escurid√£o.<br>Voc√™ √© Mais do Que o Arqueiro Lend√°rio, Voc√™ √© o Deus Arqueiro!</p>
    <button onclick="backToMenu()">JOGAR NOVAMENTE</button>
  </div>
  
  <script>
    function createMenuParticles() {
      const colors = hellMode ? ['#ff5555', '#ff0000', '#ff8800', '#ffcc00'] : ['#00ff88', '#00ffff', '#ff00ff', '#ffff00'];
      for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = hellMode ? 'particle hell-particle' : 'particle';
        
        const size = Math.random() * 5 + 2;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        particle.style.opacity = Math.random() * 0.5 + 0.1;
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        
        document.body.appendChild(particle);
        
        setInterval(() => {
          particle.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
        }, Math.random() * 2000 + 1000);
      }
    }
    
    function simulateLoading() {
      let progress = 0;
      const loadingInterval = setInterval(() => {
        progress += Math.random() * 10 + 5;
        if (progress >= 100) {
          progress = 100;
          clearInterval(loadingInterval);
          setTimeout(() => {
            document.getElementById('loading-screen').style.display = 'none';
            createMenuParticles();
          }, 500);
        }
        document.getElementById('loading-progress').style.width = `${progress}%`;
        document.getElementById('loading-text').textContent = 
          progress < 30 ? "Carregando recursos..." :
          progress < 70 ? "Preparando inimigos..." :
          "Quase l√°...";
      }, 200);
    }
    
    simulateLoading();

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const waveDisplay = document.getElementById('wave-display');
    const victoryScreen = document.getElementById('victory-screen');
    const hellVictoryScreen = document.getElementById('hell-victory-screen');

    let keys = {}, mouse = { x: 0, y: 0, clicked: false };
    let selectedSpecial = 'explosive';
    let gameActive = false;
    let hellMode = false;
    let score = 0;
    let highScore = localStorage.getItem('highScore') || 0;

    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('mousedown', () => mouse.clicked = true);
    canvas.addEventListener('mouseup', () => mouse.clicked = false);

    function selectPower(power) {
      selectedSpecial = power;
      document.querySelectorAll('.power-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      event.currentTarget.classList.add('selected');
    }

    function startGame() {
      hellMode = false;
      document.body.classList.remove('hell-mode');
      canvas.classList.remove('hell-canvas');
      waveDisplay.classList.remove('hell-wave');
      document.getElementById('menu').style.display = 'none';
      canvas.style.display = 'block';
      waveDisplay.style.display = 'block';
      gameActive = true;
      score = 0;
      init();
    }

    function startHellMode() {
      hellMode = true;
      document.body.classList.add('hell-mode');
      canvas.classList.add('hell-canvas');
      waveDisplay.classList.add('hell-wave');
      victoryScreen.style.display = 'none';
      canvas.style.display = 'block';
      waveDisplay.style.display = 'block';
      gameActive = true;
      currentWave = 16;
      init();
    }

    function backToMenu() {
      victoryScreen.style.display = 'none';
      hellVictoryScreen.style.display = 'none';
      document.getElementById('menu').style.display = 'block';
      canvas.style.display = 'none';
      waveDisplay.style.display = 'none';
      gameActive = false;
      hellMode = false;
      document.body.classList.remove('hell-mode');
      canvas.classList.remove('hell-canvas');
      waveDisplay.classList.remove('hell-wave');
    }


    class Player {
      constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.speed = 5;
        this.radius = 25;
        this.health = 150;
        this.maxHealth = 150;
        this.shootCooldown = 0;
        this.specialCooldown = 0;
        this.shieldActive = false;
        this.shieldTimer = 0;
        this.slowTimer = 0;
        this.originalSpeed = this.speed;
        this.dashCooldown = 0;
        this.dashing = false;
        this.dashTimer = 0;
        this.invulnerable = false;
        this.kills = 0;
        this.combo = 0;
        this.comboTimer = 0;
        this.rapidFireTimer = 0;
        this.rapidFireActive = false;
        this.burnTimer = 0;
        this.specialCooldowns = {
          explosive: 0,
          multi: 0,
          freeze: 0,
          lightning: 0,
          shield: 0,
          meteor: 0
        };
        this.bowAngle = 0;
        this.bowAnimation = 0;
        this.capeAnimation = 0;
        this.particles = [];
      }

      update() {
        this.capeAnimation += 0.1;
        
        if (this.burnTimer > 0) {
          this.burnTimer--;
          if (this.burnTimer % 60 === 0) {
            this.takeDamage(10);
          }
        }

        if (this.slowTimer > 0) {
          this.slowTimer--;
          this.speed = this.originalSpeed * 0.7;
        } else {
          this.speed = this.originalSpeed;
        }

        if (this.rapidFireActive) {
          this.rapidFireTimer--;
          if (this.rapidFireTimer <= 0) {
            this.rapidFireActive = false;
          }
        }

        if (keys["KeyQ"] && this.dashCooldown <= 0 && !this.dashing) {
          this.dashing = true;
          this.dashTimer = 15;
          this.dashCooldown = 120;
          this.invulnerable = true;
          this.speed *= 7;
          
          // Efeito de dash
          for (let i = 0; i < 20; i++) {
            this.particles.push({
              x: this.x,
              y: this.y,
              dx: (Math.random() - 0.5) * 10,
              dy: (Math.random() - 0.5) * 10,
              size: Math.random() * 5 + 2,
              life: 30,
              color: hellMode ? '#ff5555' : '#00ffff'
            });
          }
        }

        if (this.dashing) {
          this.dashTimer--;
          if (this.dashTimer <= 0) {
            this.dashing = false;
            this.invulnerable = false;
            this.speed = this.originalSpeed;
          }
        }

        if (this.dashCooldown > 0) this.dashCooldown--;

        if (keys["KeyW"]) this.y -= this.speed;
        if (keys["KeyS"]) this.y += this.speed;
        if (keys["KeyA"]) this.x -= this.speed;
        if (keys["KeyD"]) this.x += this.speed;
        
        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

        const shootSpeed = this.rapidFireActive ? 6 : 10;
        if (mouse.clicked && this.shootCooldown <= 0) {
          const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
          arrows.push(new Arrow(this.x, this.y, angle));
          this.shootCooldown = shootSpeed;
          this.bowAnimation = 10;
          
          this.combo++;
          this.comboTimer = 20;
          
          // Efeito de disparo
          for (let i = 0; i < 5; i++) {
            this.particles.push({
              x: this.x + Math.cos(angle) * 30,
              y: this.y + Math.sin(angle) * 30,
              dx: Math.cos(angle + (Math.random() - 0.5) * 0.5) * 5,
              dy: Math.sin(angle + (Math.random() - 0.5) * 0.5) * 5,
              size: Math.random() * 3 + 1,
              life: 20,
              color: hellMode ? '#ff8888' : '#88ff88'
            });
          }
        }

        if (this.shootCooldown > 0) this.shootCooldown--;
        
        // Update all special cooldowns
        for (const key in this.specialCooldowns) {
          if (this.specialCooldowns[key] > 0) {
            this.specialCooldowns[key]--;
          }
        }

        if (this.comboTimer > 0) this.comboTimer--;
       
        if (keys["KeyE"] && this.specialCooldowns[selectedSpecial] <= 0) {
          useSpecial(this);
          // Set cooldown based on power type
          switch(selectedSpecial) {
            case 'explosive': this.specialCooldowns.explosive = 600; break;
            case 'multi': this.specialCooldowns.multi = 420; break;
            case 'freeze': this.specialCooldowns.freeze = 780; break;
            case 'lightning': this.specialCooldowns.lightning = 660; break;
            case 'shield': this.specialCooldowns.shield = 900; break;
            case 'meteor': this.specialCooldowns.meteor = 1200; break;
          }
        }

        if (this.shieldActive) {
          this.shieldTimer--;
          if (this.shieldTimer <= 0) {
            this.shieldActive = false;
          }
        }

        // Update bow animation
        if (this.bowAnimation > 0) {
          this.bowAnimation--;
        }
        
        // Update particles
        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => {
          p.x += p.dx;
          p.y += p.dy;
          p.life--;
          p.size *= 0.95;
        });
      }

      draw() {
        // Draw particles
        this.particles.forEach(p => {
          ctx.globalAlpha = p.life / 30;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        this.bowAngle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        
        if (this.dashing) {
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
          ctx.fillStyle = hellMode ? 'rgba(255, 100, 100, 0.3)' : 'rgba(0, 200, 255, 0.3)';
          ctx.fill();
        }
        
        if (this.shieldActive) {
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 15, 0, Math.PI * 2);
          ctx.strokeStyle = hellMode ? 'rgba(255, 100, 100, 0.7)' : 'rgba(0, 150, 255, 0.7)';
          ctx.lineWidth = 4;
          ctx.stroke();
          
          for (let i = 0; i < 8; i++) {
            const shieldAngle = (Date.now() / 200 + i * Math.PI / 4) % (Math.PI * 2);
            ctx.beginPath();
            ctx.arc(
              Math.cos(shieldAngle) * (this.radius + 10),
              Math.sin(shieldAngle) * (this.radius + 10),
              3, 0, Math.PI * 2
            );
            ctx.fillStyle = hellMode ? 'rgba(255, 100, 100, 0.8)' : 'rgba(0, 200, 255, 0.8)';
            ctx.fill();
          }
        }
        
        // Draw player body
        ctx.fillStyle = this.invulnerable ? (hellMode ? "#ff5555" : "#00ffff") : (hellMode ? "#ff0000" : "#00ff88");
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw player details (face)
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(-8, -8, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(8, -8, 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(-6, -8, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(10, -8, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw cape/cloak with animation
        ctx.fillStyle = hellMode ? "#8B0000" : "#0044aa";
        ctx.beginPath();
        ctx.moveTo(-this.radius, 0);
        ctx.bezierCurveTo(
          -this.radius-5, this.radius+5 + Math.sin(this.capeAnimation)*3, 
          this.radius+5, this.radius+5 + Math.sin(this.capeAnimation+1)*3, 
          this.radius, 0
        );
        ctx.fill();
        
        // Draw bow separately, positioned outside the player
        ctx.save();
        ctx.rotate(this.bowAngle);
        ctx.translate(35, 0); // Position bow outside player
        
        // Bow body with detailed design
        ctx.strokeStyle = "#8B4513";
        ctx.lineWidth = 6;
        ctx.beginPath();
        
        const pull = this.bowAnimation > 0 ? 10 - this.bowAnimation : 0;
        
        // Bow curve with animation
        ctx.moveTo(-5, -15);
        ctx.quadraticCurveTo(pull, 0, -5, 15);
        ctx.stroke();
        
        // Bow details - engravings
        ctx.strokeStyle = "#D2691E";
        ctx.lineWidth = 1;
        for (let i = -12; i <= 12; i += 4) {
          ctx.beginPath();
          ctx.moveTo(-3, i);
          ctx.lineTo(-7, i);
          ctx.stroke();
        }
        
        // Bow string
        if (this.bowAnimation > 0) {
          ctx.strokeStyle = "#DDD";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-5, -15);
          ctx.lineTo(-5 + pull/2, 0);
          ctx.lineTo(-5, 15);
          ctx.stroke();
        } else {
          ctx.strokeStyle = "#DDD";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-5, -15);
          ctx.lineTo(-5, 15);
          ctx.stroke();
        }
        
        // Bow gems/decoration
        ctx.fillStyle = hellMode ? "#ff5555" : "#00ffff";
        ctx.beginPath();
        ctx.arc(-5, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        
        ctx.restore();
      }
      
      takeDamage(amount) {
        if (!this.shieldActive && !this.invulnerable) {
          this.health -= amount;
          
          this.combo = 0;
          this.comboTimer = 0;
          
          // Damage flash effect
          ctx.fillStyle = hellMode ? 'rgba(255, 0, 0, 0.7)' : 'rgba(255, 0, 0, 0.5)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Damage particles
          for (let i = 0; i < 10; i++) {
            this.particles.push({
              x: this.x,
              y: this.y,
              dx: (Math.random() - 0.5) * 8,
              dy: (Math.random() - 0.5) * 8,
              size: Math.random() * 4 + 2,
              life: 20,
              color: '#ff0000'
            });
          }
        }
      }
      
      applyBurn(duration) {
        this.burnTimer = Math.max(this.burnTimer, duration * 60);
      }
    }

    class Arrow {
      constructor(x, y, angle, specialEffect = null) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 12;
        this.dx = Math.cos(angle) * this.speed;
        this.dy = Math.sin(angle) * this.speed;
        this.alive = true;
        this.specialEffect = specialEffect;
        this.lifetime = 120;
        this.damage = 25;
        this.pierce = 0;
        this.trail = [];
        this.particles = [];
        
        if (specialEffect === 'lightning') {
          this.damage = 40;
          this.pierce = 2;
        } else if (specialEffect === 'explosive') {
          this.damage = 35;
        }
      }

      update() {
        // Store trail positions
        if (this.trail.length > 5) this.trail.shift();
        this.trail.push({x: this.x, y: this.y});
        
        this.x += this.dx;
        this.y += this.dy;
        this.lifetime--;
        
        // Add particles for trail effect
        if (this.lifetime % 3 === 0) {
          this.particles.push({
            x: this.x,
            y: this.y,
            size: Math.random() * 3 + 1,
            life: 20,
            color: this.specialEffect === 'lightning' ? 'cyan' : 
                  this.specialEffect === 'explosive' ? 'orange' : 
                  hellMode ? '#ff8888' : '#88ff88'
          });
        }
        
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.lifetime <= 0) {
          this.alive = false;
          
          if (this.specialEffect === 'explosive') {
            explosions.push(new Explosion(this.x, this.y, 72));
          }
        }
        
        // Update particles
        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.life--);
      }

      draw() {
        // Draw particles
        this.particles.forEach(p => {
          ctx.globalAlpha = p.life / 20;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;
        
        // Draw trail
        if (this.trail.length > 1) {
          ctx.strokeStyle = hellMode ? 'rgba(255, 100, 100, 0.3)' : 'rgba(0, 255, 255, 0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) {
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.stroke();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        if (this.specialEffect === 'lightning') {
          // Lightning arrow with detailed effects
          ctx.fillStyle = "gold";
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(25, 0);
          ctx.stroke();
          
          // Lightning effects around the arrow
          for (let i = 0; i < 6; i++) {
            const offset = Math.random() * 6 - 3;
            ctx.beginPath();
            ctx.moveTo(i * 4, offset);
            ctx.lineTo((i + 1) * 4, offset + (Math.random() * 6 - 3));
            ctx.strokeStyle = "cyan";
            ctx.stroke();
          }
          
          // Lightning aura
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 150, 0.3)';
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(0, 0, 15, 0, Math.PI * 2);
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
          gradient.addColorStop(0, 'rgba(0, 255, 255, 0.5)');
          gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
          ctx.fillStyle = gradient;
          ctx.fill();
        } else if (this.specialEffect === 'explosive') {
          // Explosive arrow with fire effects
          const gradient = ctx.createLinearGradient(0, -5, 25, 0);
          gradient.addColorStop(0, 'red');
          gradient.addColorStop(0.5, 'orange');
          gradient.addColorStop(1, 'yellow');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, -4, 25, 8);
          
          // Explosive tip
          ctx.beginPath();
          ctx.arc(25, 0, 5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 100, 0, 0.7)';
          ctx.fill();
          
          // Fire particles
          for (let i = 0; i < 3; i++) {
            ctx.fillStyle = `rgba(255, ${150 + Math.random() * 100}, 0, 0.8)`;
            ctx.beginPath();
            ctx.arc(25 + Math.random() * 5, Math.random() * 8 - 4, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Explosive aura
          ctx.beginPath();
          ctx.arc(0, 0, 12, 0, Math.PI * 2);
          const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 12);
          auraGradient.addColorStop(0, 'rgba(255, 100, 0, 0.5)');
          auraGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
          ctx.fillStyle = auraGradient;
          ctx.fill();
        } else {
          // Regular arrow with detailed design
          const gradient = ctx.createLinearGradient(0, -3, 25, 0);
          gradient.addColorStop(0, hellMode ? '#ff0000' : '#00ff88');
          gradient.addColorStop(1, hellMode ? '#ff5555' : '#00ffff');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, -3, 25, 6);
          
          // Arrowhead
          ctx.beginPath();
          ctx.moveTo(25, 0);
          ctx.lineTo(20, -4);
          ctx.lineTo(20, 4);
          ctx.closePath();
          ctx.fillStyle = 'silver';
          ctx.fill();
          
          // Fletching
          ctx.fillStyle = hellMode ? '#ff5555' : '#ff00ff';
          ctx.beginPath();
          ctx.moveTo(0, -3);
          ctx.lineTo(-5, -6);
          ctx.lineTo(-5, 0);
          ctx.closePath();
          ctx.fill();
          
          ctx.fillStyle = hellMode ? '#ff8888' : '#00ffff';
          ctx.beginPath();
          ctx.moveTo(0, 3);
          ctx.lineTo(-5, 6);
          ctx.lineTo(-5, 0);
          ctx.closePath();
          ctx.fill();
          
          // Arrow details
          ctx.strokeStyle = hellMode ? '#ff8888' : '#00aaaa';
          ctx.lineWidth = 1;
          for (let i = 5; i < 20; i += 5) {
            ctx.beginPath();
            ctx.moveTo(i, -2);
            ctx.lineTo(i, 2);
            ctx.stroke();
          }
        }
        
        ctx.restore();
      }
    }

    class Enemy {
      constructor(type = 1, wave = 1) {
        this.type = type;
        this.wave = wave;
        
        if (Math.random() < 0.5) {
          this.x = Math.random() < 0.5 ? 0 : canvas.width;
          this.y = Math.random() * canvas.height;
        } else {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() < 0.5 ? 0 : canvas.height;
        }
        
        switch(type) {
          case 1: // Basic enemy
            this.radius = 18;
            this.speed = 2.5 + wave * 0.07;
            this.health = 40 + wave * 3;
            this.color = hellMode ? "#ff8888" : "#ff5555";
            this.damage = 0.5;
            this.scoreValue = 10;
            this.burnTimer = 0;
            break;
          case 2: // Tank enemy
            this.radius = 22;
            this.speed = 2 + wave * 0.05;
            this.health = 100 + wave * 6;
            this.color = hellMode ? "#ff3333" : "#aa0000";
            this.damage = 0.8;
            this.scoreValue = 25;
            this.burnTimer = 0;
            break;
          case 3: // Fast enemy
            this.radius = 15;
            this.speed = 3.6 + wave * 0.09;
            this.health = 30 + wave * 2;
            this.color = hellMode ? "#ffcc00" : "#ffaa00";
            this.damage = 0.3;
            this.scoreValue = 15;
            this.burnTimer = 0;
            break;
          case 4: // Big enemy
            this.radius = 30;
            this.speed = 1.2 + wave * 0.03;
            this.health = 200 + wave * 10;
            this.color = hellMode ? "#8888ff" : "#5555ff";
            this.damage = 1.2;
            this.scoreValue = 40;
            this.burnTimer = 0;
            break;
          case 5: // Ranged enemy
            this.radius = 20;
            this.speed = 2 + wave * 0.06;
            this.health = 70 + wave * 4;
            this.color = hellMode ? "#ff00ff" : "#aa00aa";
            this.damage = 0.6;
            this.shootCooldown = 0;
            this.shootingRange = 300;
            this.scoreValue = 30;
            this.burnTimer = 0;
            break;
          case 6: // Wave 5 Boss - Rei Violeta
            this.radius = 55;
            this.speed = 3.5;
            this.health = 500 + wave * 40;
            this.color = hellMode ? "#ff00ff" : "#aa00aa";
            this.damage = 2;
            this.shootCooldown = 0;
            this.fireTrailCooldown = 0;
            this.fireTrails = [];
            this.scoreValue = 200;
            this.burnTimer = 0;
            this.animationTimer = 0;
            break;
          case 7: // Wave 10 Boss - Rei Dourado
            this.radius = 55;
            this.speed = 3;
            this.health = (500 + wave * 40) * 1.4;
            this.color = hellMode ? "#ffff00" : "#ffcc00";
            this.damage = 2;
            this.shootCooldown = 0;
            this.specialCooldown = 0;
            this.scoreValue = 400;
            this.burnTimer = 0;
            this.animationTimer = 0;
            break;
          case 8: // Final Boss - Imperador do Mundo
            this.radius = 70;
            this.speed = 2.8;
            this.health = (500 + wave * 40) * 2;
            this.color = hellMode ? "#ff4500" : "#ff3300";
            this.damage = 3;
            this.shootCooldown = 0;
            this.minionCooldown = 0;
            this.phase = 1;
            this.auraActive = false;
            this.scoreValue = 1000;
            this.burnTimer = 0;
            this.animationTimer = 0;
            break;
          case 9: // Hell Boss - Devorador de Almas
            this.radius = 80;
            this.speed = 0; 
            this.health = (500 + wave * 40) * 2.3; 
            this.damage = 1;
            this.color = "#330033";
            this.shootCooldown = 0;
            this.meteorCooldown = 0;
            this.teleportCooldown = 0;
            this.radialAttackCooldown = 0;
            this.eyesColor = "#9900ff";
            this.auraColor = "#ff0000";
            this.scoreValue = 2000;
            this.burnTimer = 0;
            this.animationTimer = 0;
            break;
        }
        
        this.maxHealth = this.health;
        this.originalSpeed = this.speed;
        this.slowTimer = 0;
        this.hitFlash = 0;
        this.stunnedTimer = 0;
        this.frozenColor = "#00aaff";
        this.isFrozen = false;
        this.burnDamageTimer = 0;
      }

      update() {
        this.animationTimer++;
        
        if (this.burnTimer > 0) {
          this.burnTimer--;
          this.burnDamageTimer--;
          
          if (this.burnDamageTimer <= 0) {
            this.takeDamage(10);
            this.burnDamageTimer = 60; // Damage every second
          }
        }
        
        if (this.stunnedTimer > 0) {
          this.stunnedTimer--;
          return;
        }

        if (this.slowTimer > 0) {
          this.slowTimer--;
          this.speed = this.originalSpeed * 0.3;
          this.isFrozen = true;
        } else {
          this.speed = this.originalSpeed;
          this.isFrozen = false;
        }

        if (this.hitFlash > 0) this.hitFlash--;

        if (this.type === 5) { 
          const distanceToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
          
          if (distanceToPlayer > this.shootingRange) {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;
          }
          
          if (this.shootCooldown <= 0) {
            const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
            enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle, this.type));
            this.shootCooldown = 90;
          }
          
          if (this.shootCooldown > 0) this.shootCooldown--;
        }
        else if (this.type === 6 || this.type === 7 || this.type === 8 || this.type === 9) {
          const angle = Math.atan2(player.y - this.y, player.x - this.x);
          this.x += Math.cos(angle) * this.speed;
          this.y += Math.sin(angle) * this.speed;
          
          if (this.type === 6) { 
            this.fireTrailCooldown--;
            if (this.fireTrailCooldown <= 0) {
              this.fireTrails.push(new FireTrail(this.x, this.y));
              this.fireTrailCooldown = 50; 
            }
            
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle, this.type));
              this.shootCooldown = 20;
            }
          }
          else if (this.type === 7) {
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              for (let i = -1; i <= 1; i++) {
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle + (i * 0.3), this.type));
              }
              this.shootCooldown = 80;
            }
            
            this.specialCooldown--;
            if (this.specialCooldown <= 0) {
              for (let i = 0; i < 36; i++) {
                const angle = (i / 36) * Math.PI * 2;
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angle, 'energy'));
              }
              this.specialCooldown = 500;
            }
          }
          else if (this.type === 8) { 
            if (this.health < this.maxHealth / 2 && this.phase === 1) {
              this.phase = 2;
              this.color = "#ff0000";
              this.damage *= 1.5;
              this.auraActive = true;
              this.speed *= 1.2;
            }
            
            this.minionCooldown--;
            const minionInterval = this.phase === 1 ? 200 : 120; 
            if (this.minionCooldown <= 0) {
              enemies.push(new Enemy(1, this.wave + 5));
              enemies.push(new Enemy(3, this.wave + 5));
              this.minionCooldown = minionInterval;
            }
            
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              for (let i = 0; i < 12; i++) {
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle + (i * Math.PI / 6), this.type));
              }
              this.shootCooldown = 40;
            }
          }
          else if (this.type === 9) {
            this.teleportCooldown--;
            if (this.teleportCooldown <= 0) {
              this.x = Math.random() * (canvas.width - 200) + 100;
              this.y = Math.random() * (canvas.height - 200) + 100;
              this.teleportCooldown = 90;
            }
            
            this.shootCooldown--;
            if (this.shootCooldown <= 0) {
              const angle = Math.atan2(player.y - this.y, player.x - this.x);
              for (let i = -1; i <= 1; i++) {
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angle + (i * 0.3), this.type));
              }
              this.shootCooldown = 240;
            }
            
            if (this.shootCooldown === 180) {
              const angle = Math.atan2(player.y - this.y, player.x - this.x);
              enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angle + Math.PI/2, 'homing'));
              enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angle - Math.PI/2, 'homing'));
            }
            
            this.meteorCooldown--;
            if (this.meteorCooldown <= 0) {
              darkMeteors.push(new DarkMeteor(player.x, player.y));
              this.meteorCooldown = 240;
            }
            
            this.radialAttackCooldown--;
            if (this.radialAttackCooldown <= 0) {
              for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angle, 'burning'));
              }
              this.radialAttackCooldown = 600;
            }
          }
          
          if (this.shootCooldown > 0) this.shootCooldown--;
        } 
        else {
          const angle = Math.atan2(player.y - this.y, player.x - this.x);
          this.x += Math.cos(angle) * this.speed;
          this.y += Math.sin(angle) * this.speed;
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.hitFlash > 0) {
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw burning effect if active
        if (this.burnTimer > 0) {
          for (let i = 0; i < 3; i++) {
            const flameX = Math.random() * this.radius * 2 - this.radius;
            const flameY = Math.random() * this.radius * 2 - this.radius;
            const flameSize = Math.random() * 5 + 3;
            
            ctx.fillStyle = `rgba(255, ${100 + Math.floor(Math.random() * 100)}, 0, 0.8)`;
            ctx.beginPath();
            ctx.arc(flameX, flameY - 10, flameSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Draw stunned/lightning effect if active
        if (this.stunnedTimer > 0) {
          ctx.strokeStyle = "cyan";
          ctx.lineWidth = 2;
          ctx.beginPath();
          
          for (let i = 0; i < 5; i++) {
            const startAngle = Math.random() * Math.PI * 2;
            const endAngle = startAngle + Math.PI / 4;
            ctx.arc(0, 0, this.radius + 10, startAngle, endAngle);
          }
          
          ctx.stroke();
        }
        
        ctx.fillStyle = this.isFrozen ? this.frozenColor : this.color;
        
        switch(this.type) {
          case 1: // Basic enemy - Goblin
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(-5, -5, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5, -5, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(-5, -5, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5, -5, 1, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 3, 5, 0.1, Math.PI - 0.1);
            ctx.stroke();
            
            // Spikes
            ctx.strokeStyle = hellMode ? "#ff5555" : "#555555";
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              ctx.beginPath();
              ctx.moveTo(
                Math.cos(angle) * this.radius,
                Math.sin(angle) * this.radius
              );
              ctx.lineTo(
                Math.cos(angle) * (this.radius + 5),
                Math.sin(angle) * (this.radius + 5)
              );
              ctx.stroke();
            }
            break;
            
          case 2: // Tank enemy - Orc
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Armor details
            ctx.fillStyle = hellMode ? "#aa0000" : "#333333";
            ctx.fillRect(-this.radius + 2, -this.radius + 5, this.radius * 2 - 4, 10);
            ctx.fillRect(-this.radius + 2, this.radius - 15, this.radius * 2 - 4, 10);
            
            // Eyes
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(-7, -5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(7, -5, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(-7, -5, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(7, -5, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Tusks
            ctx.strokeStyle = "white";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-5, 5);
            ctx.lineTo(-10, 10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(5, 5);
            ctx.lineTo(10, 10);
            ctx.stroke();
            break;
            
          case 3: // Fast enemy - Imp
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Wings
            ctx.fillStyle = hellMode ? "rgba(255, 200, 0, 0.6)" : "rgba(255, 255, 255, 0.6)";
            ctx.beginPath();
            ctx.ellipse(-15, -10, 10, 15, -Math.PI/4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(15, -10, 10, 15, Math.PI/4, 0, Math.PI * 2);
            ctx.fill();
            
            // Horns
            ctx.fillStyle = hellMode ? "#ff5555" : "#555555";
            ctx.beginPath();
            ctx.moveTo(-5, -this.radius);
            ctx.lineTo(-10, -this.radius - 8);
            ctx.lineTo(-3, -this.radius - 5);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(5, -this.radius);
            ctx.lineTo(10, -this.radius - 8);
            ctx.lineTo(3, -this.radius - 5);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(-4, -2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(4, -2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(-4, -2, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(4, -2, 1, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 4: // Big enemy - Ogre
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Club
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(this.radius - 5, -20, 15, 40);
            
            // Spikes on club
            ctx.fillStyle = "#555555";
            for (let i = -15; i < 15; i += 10) {
              ctx.beginPath();
              ctx.moveTo(this.radius + 10, i);
              ctx.lineTo(this.radius + 20, i + 5);
              ctx.lineTo(this.radius + 10, i + 10);
              ctx.fill();
            }
            
            // Belly
            ctx.fillStyle = hellMode ? "#ff8888" : "#ffaaaa";
            ctx.beginPath();
            ctx.arc(0, 5, this.radius - 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(-10, -8, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(10, -8, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(-10, -8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(10, -8, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 5, 10, 0, Math.PI);
            ctx.stroke();
            break;
            
          case 5: // Ranged enemy - Mage
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Robe details
            ctx.fillStyle = hellMode ? "#550055" : "#330033";
            ctx.beginPath();
            ctx.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Staff
            ctx.strokeStyle = "#8B4513";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -this.radius);
            ctx.lineTo(0, this.radius);
            ctx.stroke();
            
            // Gem on staff
            ctx.fillStyle = hellMode ? "#ff00ff" : "#aa00aa";
            ctx.beginPath();
            ctx.arc(0, -this.radius + 5, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(-5, -5, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5, -5, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "cyan";
            ctx.beginPath();
            ctx.arc(-5, -5, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5, -5, 1, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 6: // Rei Violeta
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            ctx.rotate(angle);
            
            // Crown
            ctx.fillStyle = hellMode ? "#ff00ff" : "#aa00aa";
            for (let i = -1; i <= 1; i++) {
              ctx.beginPath();
              ctx.moveTo(i * 15, -this.radius - 10);
              ctx.lineTo(i * 15 + 7, -this.radius - 20);
              ctx.lineTo(i * 15 - 7, -this.radius - 20);
              ctx.fill();
            }
            
            // Jewel in crown
            ctx.fillStyle = "#00ffff";
            ctx.beginPath();
              ctx.arc(0, -this.radius - 15, 5, 0, Math.PI * 2);
              ctx.fill();
            
            // Body
            ctx.fillStyle = this.isFrozen ? this.frozenColor : this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Royal robe pattern
            ctx.fillStyle = hellMode ? "#ff88ff" : "#ff00ff";
            for (let i = 0; i < 8; i++) {
              const patternAngle = (i / 8) * Math.PI * 2 + this.animationTimer / 20;
              ctx.beginPath();
              ctx.arc(
                Math.cos(patternAngle) * (this.radius - 5),
                Math.sin(patternAngle) * (this.radius - 5),
                3, 0, Math.PI * 2
              );
              ctx.fill();
            }
            
            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(15, -10, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(15, 10, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(18, -10, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(18, 10, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(10, 0, 5, 0, Math.PI);
            ctx.stroke();
            
            // Aura
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 15, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius + 15);
            gradient.addColorStop(0, 'rgba(170, 0, 170, 0.3)');
            gradient.addColorStop(1, 'rgba(170, 0, 170, 0)');
            ctx.fillStyle = gradient;
            ctx.fill();
            break;
            
          case 7: // Rei Dourado
            ctx.rotate(Math.atan2(player.y - this.y, player.x - this.x));
            
            // Crown with jewels
            ctx.fillStyle = hellMode ? "#ffff00" : "#ffcc00";
            for (let i = -1; i <= 1; i++) {
              ctx.beginPath();
              ctx.moveTo(i * 15, -this.radius - 10);
              ctx.lineTo(i * 15 + 7, -this.radius - 20);
              ctx.lineTo(i * 15 - 7, -this.radius - 20);
              ctx.fill();
              
              // Jewels in crown
              ctx.fillStyle = i === 0 ? "#ff0000" : "#00ff00";
              ctx.beginPath();
              ctx.arc(i * 15, -this.radius - 15, 3, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = hellMode ? "#ffff00" : "#ffcc00";
            }
            
            // Body
            ctx.fillStyle = this.isFrozen ? this.frozenColor : this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Sun pattern
            ctx.fillStyle = hellMode ? "#ffaa00" : "#ff9900";
            for (let i = 0; i < 12; i++) {
              const rayAngle = (i / 12) * Math.PI * 2 + this.animationTimer / 30;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(
                Math.cos(rayAngle) * (this.radius + 10),
                Math.sin(rayAngle) * (this.radius + 10)
              );
              ctx.lineWidth = 3;
              ctx.stroke();
            }
            
            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(15, -10, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(15, 10, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(18, -10, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(18, 10, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(10, 0, 5, 0, Math.PI);
            ctx.stroke();
            
            // Golden aura
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 15, 0, Math.PI * 2);
            const goldGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius + 15);
            goldGradient.addColorStop(0, 'rgba(255, 204, 0, 0.4)');
            goldGradient.addColorStop(1, 'rgba(255, 204, 0, 0)');
            ctx.fillStyle = goldGradient;
            ctx.fill();
            break;
            
          case 8: // Imperador do Mundo
            ctx.rotate(Math.atan2(player.y - this.y, player.x - this.x));
            
            // Imperial crown
            ctx.fillStyle = hellMode ? "#ff3300" : "#cc2200";
            ctx.beginPath();
            ctx.moveTo(-20, -this.radius - 5);
            ctx.lineTo(20, -this.radius - 5);
            ctx.lineTo(20, -this.radius - 15);
            ctx.lineTo(0, -this.radius - 25);
            ctx.lineTo(-20, -this.radius - 15);
            ctx.closePath();
            ctx.fill();
            
            // Jewels in crown
            ctx.fillStyle = "#00ccff";
            ctx.beginPath();
            ctx.arc(0, -this.radius - 20, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            ctx.fillStyle = this.isFrozen ? this.frozenColor : this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Imperial insignia
            ctx.fillStyle = hellMode ? "#ff5500" : "#ff0000";
            ctx.beginPath();
            ctx.moveTo(0, -this.radius + 10);
            ctx.lineTo(-10, 0);
            ctx.lineTo(0, this.radius - 10);
            ctx.lineTo(10, 0);
            ctx.closePath();
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(15, -10, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(15, 10, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(18, -10, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(18, 10, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(10, 0, 5, 0, Math.PI);
            ctx.stroke();
            
            // Phase 2 aura
            if (this.phase === 2) {
              ctx.beginPath();
              ctx.arc(0, 0, this.radius + 20, 0, Math.PI * 2);
              const phaseGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius + 20);
              phaseGradient.addColorStop(0, 'rgba(255, 0, 0, 0.5)');
              phaseGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
              ctx.fillStyle = phaseGradient;
              ctx.fill();
            }
            break;
            
          case 9: // Devorador de Almas
            // Dark aura
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 25, 0, Math.PI * 2);
            const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius + 25);
            auraGradient.addColorStop(0, 'rgba(255, 0, 0, 0.5)');
            auraGradient.addColorStop(0.7, 'rgba(150, 0, 0, 0.3)');
            auraGradient.addColorStop(1, 'rgba(50, 0, 0, 0)');
            ctx.fillStyle = auraGradient;
            ctx.fill();
            
            // Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Soul patterns
            ctx.fillStyle = "#9900ff";
            for (let i = 0; i < 6; i++) {
              const soulAngle = (i / 6) * Math.PI * 2 + this.animationTimer / 20;
              ctx.beginPath();
              ctx.arc(
                Math.cos(soulAngle) * (this.radius - 10),
                Math.sin(soulAngle) * (this.radius - 10),
                5, 0, Math.PI * 2
              );
              ctx.fill();
            }
            
            // Eyes
            ctx.fillStyle = this.eyesColor;
            ctx.beginPath();
            ctx.arc(-15, -10, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(15, -10, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Pupils
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(-12, -15, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(18, -15, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(0, 10, 15, 0, Math.PI);
            ctx.fill();
            
            // Teeth
            ctx.fillStyle = "white";
            for (let i = -2; i <= 2; i++) {
              ctx.beginPath();
              ctx.moveTo(i * 5, 10);
              ctx.lineTo(i * 5 + 2, 20);
              ctx.lineTo(i * 5 - 2, 20);
              ctx.fill();
            }
            break;
            
          default:
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
        
        if (this.type === 6 || this.type === 7 || this.type === 8 || this.type === 9) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 20, this.radius * 2, 8);
          ctx.fillStyle = this.health > this.maxHealth / 2 ? "lime" : "red";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 20, this.radius * 2 * (this.health / this.maxHealth), 8);
          ctx.strokeStyle = "white";
          ctx.strokeRect(this.x - this.radius, this.y - this.radius - 20, this.radius * 2, 8);
          
          ctx.fillStyle = "white";
          ctx.font = "18px 'Press Start 2P', cursive";
          ctx.textAlign = "center";
          if (this.type === 6) {
            ctx.fillText("REI VIOLETA", this.x, this.y - this.radius - 35);
          } else if (this.type === 7) {
            ctx.fillText("REI DOURADO", this.x, this.y - this.radius - 35);
          } else if (this.type === 8) {
            ctx.fillText("IMPERADOR DO MUNDO", this.x, this.y - this.radius - 35);
          } else if (this.type === 9) {
            ctx.fillText("DEVORADOR DE ALMAS", this.x, this.y - this.radius - 35);
          }
          ctx.textAlign = "start";
        }
        
        if (this.type === 6) {
          this.fireTrails = this.fireTrails.filter(trail => trail.lifetime > 0);
          this.fireTrails.forEach(trail => {
            trail.update();
            trail.draw();
          });
        }
      }
      
      takeDamage(amount) {
        this.health -= amount;
        this.hitFlash = 3;
      }
      
      stun(duration) {
        this.stunnedTimer = duration;
      }
      
      applyBurn(duration) {
        this.burnTimer = duration * 60;
        this.burnDamageTimer = 60;
      }
    }

    class FireTrail {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 60;
        this.lifetime = 240; 
        this.damage = 0.8;
      }
      
      update() {
        this.lifetime--;
        this.radius = 60 * (this.lifetime / 240);
      }
      
      draw() {
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, 'rgba(255, 150, 0, 0.8)');
        gradient.addColorStop(0.7, 'rgba(255, 50, 0, 0.4)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        if (Math.hypot(player.x - this.x, player.y - this.y) < player.radius + this.radius) {
          if (!player.shieldActive && !player.invulnerable) {
            player.takeDamage(this.damage);
          }
        }
      }
    }

    class EnemyProjectile {
      constructor(x, y, angle, enemyType) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.enemyType = enemyType;
        
        if (enemyType === 'energy') {
          this.speed = 3.5;
          this.damage = 25;
          this.radius = 10;
          this.color = "cyan";
          this.isEnergyBall = true;
          this.homing = false;
        } 
        else if (enemyType === 'homing') {
          this.speed = 4;
          this.damage = 15;
          this.radius = 8;
          this.color = "#ff00ff";
          this.homing = true;
          this.homingPower = 0.08;
        }
        else if (enemyType === 'burning') {
          this.speed = 5;
          this.damage = 10;
          this.radius = 6;
          this.color = "#ff0000";
          this.homing = false;
          this.burning = true;
        }
        else {
          this.speed = enemyType === 7 ? 6 : enemyType === 6 ? 7 : 5;
          this.damage = enemyType === 7 ? 10 : enemyType === 6 ? 15 : 8;
          this.radius = enemyType === 7 ? 8 : enemyType === 6 ? 10 : 6;
          this.color = enemyType === 7 ? "yellow" : enemyType === 6 ? "purple" : "orange";
          this.isEnergyBall = false;
          this.homing = enemyType === 9;
          this.homingPower = enemyType === 9 ? 0.05 : 0;
        }
        
        this.alive = true;
        this.trail = [];
      }

      update() {
        // Store trail positions
        if (this.trail.length > 5) this.trail.shift();
        this.trail.push({x: this.x, y: this.y});
        
        if (this.homing) {
          const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
          const angleDiff = ((targetAngle - this.angle + 3 * Math.PI) % (2 * Math.PI)) - Math.PI;
          this.angle += Math.min(this.homingPower, Math.max(-this.homingPower, angleDiff));
        }
        
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
          this.alive = false;
        }
      }

      draw() {
        // Draw trail
        if (this.trail.length > 1) {
          ctx.strokeStyle = this.burning ? 'rgba(255, 100, 0, 0.3)' : 'rgba(200, 200, 255, 0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) {
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.stroke();
        }
        
        if (this.isEnergyBall) {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2);
          const gradient = ctx.createRadialGradient(
            this.x, this.y, 0,
            this.x, this.y, this.radius + 10
          );
          gradient.addColorStop(0, 'rgba(0, 255, 255, 0.5)');
          gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
          ctx.fillStyle = gradient;
          ctx.fill();
        } else if (this.burning) {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Efeito de chama
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.radius);
            ctx.lineTo(this.x + this.radius * 0.7, this.y + this.radius * 0.5);
            ctx.lineTo(this.x - this.radius * 0.7, this.y + this.radius * 0.5);
            ctx.closePath();
            ctx.fillStyle = `rgba(255, ${150 + i * 50}, 0, 0.7)`;
            ctx.fill();
          }
        } else {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.x - Math.cos(this.angle) * 15, this.y - Math.sin(this.angle) * 15);
          ctx.lineTo(this.x, this.y);
          ctx.stroke();
        }
      }
    }

    class DarkMeteor {
      constructor(targetX, targetY) {
        this.x = Math.random() * canvas.width;
        this.y = -100;
        this.targetX = targetX;
        this.targetY = targetY;
        this.speed = 15;
        this.radius = 30;
        this.damage = 50;
        this.impacted = false;
        this.lavaDuration = 300; 
        this.lavaRadius = 70;
        this.trail = [];
      }
      
      update() {
        // Store trail positions
        if (this.trail.length > 10) this.trail.shift();
        this.trail.push({x: this.x, y: this.y});
        
        if (!this.impacted) {
          const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
          this.x += Math.cos(angle) * this.speed;
          this.y += Math.sin(angle) * this.speed;
          
          if (Math.hypot(this.targetX - this.x, this.targetY - this.y) < 10) {
            this.impacted = true;
            
            lavaPatches.push({
              x: this.x,
              y: this.y,
              radius: this.lavaRadius,
              lifetime: this.lavaDuration
            });
            
            if (Math.hypot(player.x - this.x, player.y - this.y) < player.radius + this.radius) {
              player.takeDamage(this.damage);
            }
          }
        }
      }
      
      draw() {
        // Draw trail
        if (this.trail.length > 1 && !this.impacted) {
          ctx.strokeStyle = 'rgba(150, 0, 150, 0.3)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) {
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.stroke();
        }
        
        if (!this.impacted) {
          ctx.save();
          ctx.translate(this.x, this.y);
          
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
          gradient.addColorStop(0, '#660066');
          gradient.addColorStop(0.7, '#330033');
          gradient.addColorStop(1, '#000000');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = 'rgba(150, 0, 150, 0.7)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-this.speed * 2, -this.speed * 3);
          ctx.stroke();
          
          ctx.restore();
        }
      }
      
      isActive() {
        return !this.impacted;
      }
    }

    class PowerUp {
      constructor(type = null) {
        this.x = Math.random() * (canvas.width - 100) + 50;
        this.y = Math.random() * (canvas.height - 100) + 50;
        this.radius = 20;
        this.type = type || this.getRandomType();
        this.lifetime = 600; // 10 segundos
        this.floatOffset = Math.random() * Math.PI * 2;
        this.floatSpeed = Math.random() * 0.05 + 0.05;
        this.originalY = this.y;
      }
      
      getRandomType() {
        const r = Math.random();
        if (r < 0.35) return "heal";
        if (r < 0.6) return "rapid";
        if (r < 0.8) return "special";
        if (r < 0.9) return "shield";
        return "maxhp";
      }

      update() {
        this.floatOffset += this.floatSpeed;
        this.y = this.originalY + Math.sin(this.floatOffset) * 10;
        this.lifetime--;
      }

      draw() {
        this.update();
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius + 5);
        gradient.addColorStop(0, hellMode ? 'rgba(255, 100, 100, 0.3)' : 'rgba(0, 255, 255, 0.3)');
        gradient.addColorStop(1, hellMode ? 'rgba(255, 50, 50, 0)' : 'rgba(0, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fill();
        
        ctx.strokeStyle = hellMode ? "#ff5555" : "cyan";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.beginPath();
        ctx.arc(0, 0, this.radius - 3, 0, Math.PI * 2);
        ctx.fill();
        
        switch(this.type) {
          case "heal":
            ctx.fillStyle = "lime";
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(8, 8);
            ctx.lineTo(-8, 8);
            ctx.closePath();
            ctx.fill();
            break;
          case "rapid":
            ctx.fillStyle = hellMode ? "#ff5555" : "cyan";
            ctx.fillRect(-10, -4, 20, 8);
            ctx.fillRect(-4, -10, 8, 20);
            break;
          case "special":
            ctx.fillStyle = "gold";
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "rgba(255, 255, 0, 0.7)";
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              ctx.beginPath();
              ctx.arc(
                Math.cos(angle) * 15,
                Math.sin(angle) * 15,
                3, 0, Math.PI * 2
              );
              ctx.fill();
            }
            break;
          case "shield":
            ctx.strokeStyle = hellMode ? "rgba(255, 100, 100, 0.8)" : "rgba(0, 200, 255, 0.8)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(8, 0);
            ctx.lineTo(0, 8);
            ctx.lineTo(-8, 0);
            ctx.closePath();
            ctx.stroke();
            break;
          case "maxhp":
            ctx.fillStyle = "pink";
            ctx.beginPath();
            ctx.arc(0, -8, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, 8, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(-6, -2, 12, 12);
            break;
        }
        
        ctx.restore();
      }
    }

    class Meteor {
      constructor(targetX, targetY) {
        this.x = Math.random() * canvas.width;
        this.y = -100;
        this.targetX = targetX;
        this.targetY = targetY;
        this.speed = 15;
        this.radius = 30;
        this.damage = 54;
        this.impacted = false;
        this.fireDuration = 180;
        this.fireRadius = 80;
        this.trail = [];
      }
      
      update() {
        // Store trail positions
        if (this.trail.length > 10) this.trail.shift();
        this.trail.push({x: this.x, y: this.y});
        
        if (!this.impacted) {
          const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
          this.x += Math.cos(angle) * this.speed;
          this.y += Math.sin(angle) * this.speed;
          
          if (Math.hypot(this.targetX - this.x, this.targetY - this.y) < 10) {
            this.impacted = true;
            
            [...enemies, ...bosses].forEach(e => {
              const dist = Math.hypot(this.x - e.x, this.y - e.y);
              if (dist < this.radius + e.radius) {
                e.takeDamage(this.damage);
              }
            });
            
            // Create lava patch
            lavaPatches.push({
              x: this.x,
              y: this.y,
              radius: this.fireRadius,
              lifetime: this.fireDuration
            });
          }
        } else {
          this.fireDuration--;
        }
      }
      
      draw() {
        // Draw trail
        if (this.trail.length > 1 && !this.impacted) {
          ctx.strokeStyle = 'rgba(255, 100, 0, 0.3)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) {
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.stroke();
        }
        
        if (!this.impacted) {
          ctx.save();
          ctx.translate(this.x, this.y);
          
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
          gradient.addColorStop(0, 'orange');
          gradient.addColorStop(0.7, 'red');
          gradient.addColorStop(1, 'darkred');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = 'rgba(255, 165, 0, 0.7)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-this.speed * 2, -this.speed * 3);
          ctx.stroke();
          
          ctx.restore();
        } else if (this.fireDuration > 0) {
          const gradient = ctx.createRadialGradient(
            this.x, this.y, 0,
            this.x, this.y, this.fireRadius
          );
          gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
          gradient.addColorStop(0.7, 'rgba(255, 50, 0, 0.4)');
          gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.fireRadius * (this.fireDuration / 180), 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      isActive() {
        return !this.impacted || this.fireDuration > 0;
      }
    }

    function useSpecial(player) {
      const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
      
      switch(selectedSpecial) {
        case "explosive":
          explosions.push(new Explosion(player.x, player.y, 180));
          
          [...enemies, ...bosses].forEach(e => {
            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            if (dist < 180) {
              e.takeDamage(90 + (dist < 90 ? 40 : 0));
              
              const knockbackAngle = Math.atan2(e.y - player.y, e.x - player.x);
              const knockbackPower = 10 * (1 - dist / 180);
              e.x += Math.cos(knockbackAngle) * knockbackPower;
              e.y += Math.sin(knockbackAngle) * knockbackPower;
            }
          });
          break;
          
        case "multi":
          // Visual effect for multi-arrow
          for (let i = 0; i < 20; i++) {
            const particleAngle = Math.random() * Math.PI * 2;
            const particleDist = Math.random() * 50;
            const particleX = player.x + Math.cos(particleAngle) * particleDist;
            const particleY = player.y + Math.sin(particleAngle) * particleDist;
            
            ctx.fillStyle = hellMode ? 'rgba(255, 100, 100, 0.7)' : 'rgba(0, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
            ctx.fill();
          }
          
          for (let i = -11; i <= 11; i++) {
            arrows.push(new Arrow(player.x, player.y, angle + i * 0.03));
          }
          break;
          
        case "freeze":
          enemies.forEach(e => {
            e.speed *= 0.1;
            e.slowTimer = 360; 
            e.isFrozen = true;
          });
          bosses.forEach(b => {
            b.speed *= 0.3;
            b.slowTimer = 180; 
            b.isFrozen = true;
          });
          freezeEffects.push(new FreezeEffect(player.x, player.y));
          break;
          
        case "lightning":
          const lightningTargets = [...enemies, ...bosses].filter(e => 
            Math.hypot(player.x - e.x, player.y - e.y) < 250
          ).sort((a, b) => 
            Math.hypot(player.x - a.x, player.y - a.y) - Math.hypot(player.x - b.x, player.y - b.y)
          ).slice(0, 12);
          
          if (lightningTargets.length > 0) {
            lightningEffects.push(new LightningEffect(player, lightningTargets));
            
            lightningTargets.forEach((target, i) => {
              target.takeDamage(75 / (i + 1));
              target.stun(30);
              if (target.type === 5 || target.type === 6 || target.type === 7 || target.type === 8 || target.type === 9) {
                target.shootCooldown += 90; 
              }
            });
          }
          break;
          
        case "shield":
          player.shieldActive = true;
          player.shieldTimer = 360;
          
          // Shield activation effect
          for (let i = 0; i < 30; i++) {
            const shieldAngle = Math.random() * Math.PI * 2;
            const shieldDist = Math.random() * 40;
            const shieldX = player.x + Math.cos(shieldAngle) * shieldDist;
            const shieldY = player.y + Math.sin(shieldAngle) * shieldDist;
            
            ctx.fillStyle = hellMode ? 'rgba(255, 100, 100, 0.7)' : 'rgba(0, 200, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(shieldX, shieldY, 4, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
          
        case "meteor":
          // Meteor call effect
          for (let i = 0; i < 50; i++) {
            const starX = Math.random() * canvas.width;
            const starY = Math.random() * canvas.height / 2;
            const starSize = Math.random() * 3 + 1;
            
            ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
            ctx.fillRect(starX, starY, starSize, starSize);
          }
          
          for (let i = 0; i < 18; i++) {
            setTimeout(() => {
              const x = Math.random() * (canvas.width - 200) + 100;
              const y = Math.random() * (canvas.height - 200) + 100;
              meteors.push(new Meteor(x, y));
            }, i * 250);
          }
          break;
      }
    }

    class Explosion {
      constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = 100;
        this.maxRadius = 100;
        this.lifetime = 100;
        this.particles = [];
        
        // Create explosion particles
        for (let i = 0; i < 50; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 5 + 2;
          this.particles.push({
            x: this.x,
            y: this.y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            size: Math.random() * 5 + 2,
            life: Math.random() * 30 + 20
          });
        }
      }
      
      update() {
        this.lifetime--;
        this.radius = this.maxRadius * (this.lifetime / 30);
        
        // Update particles
        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => {
          p.x += p.dx;
          p.y += p.dy;
          p.life--;
          p.size *= 0.95;
        });
      }
      
      draw() {
        // Draw particles
        this.particles.forEach(p => {
          ctx.fillStyle = `rgba(255, ${100 + Math.floor(p.life * 5)}, 0, ${p.life / 50})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
        
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
        gradient.addColorStop(0.8, 'rgba(255, 50, 0, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        
        // Shockwave effect
        ctx.strokeStyle = `rgba(255, 200, 100, ${this.lifetime / 100})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 1.2, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    class FreezeEffect {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 500;
        this.lifetime = 60;
        this.snowParticles = [];
        
        // Create initial snow particles
        for (let i = 0; i < 100; i++) {
          this.snowParticles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 4 + 1,
            speed: Math.random() * 2 + 1
          });
        }
      }
      
      update() {
        this.lifetime--;
        
        // Update snow particles
        this.snowParticles.forEach(p => {
          p.y += p.speed;
          if (p.y > canvas.height) {
            p.y = 0;
            p.x = Math.random() * canvas.width;
          }
        });
        
        // Add new snow particles
        if (this.lifetime % 5 === 0) {
          this.snowParticles.push({
            x: Math.random() * canvas.width,
            y: 0,
            size: Math.random() * 4 + 1,
            speed: Math.random() * 2 + 1
          });
        }
      }
      
      draw() {
        // Draw snow particles
        this.snowParticles.forEach(p => {
          ctx.fillStyle = `rgba(255, 255, 255, ${this.lifetime / 60})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
        
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, 'rgba(0, 200, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(0, 100, 255, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * this.radius;
          const size = Math.random() * 10 + 5;
          
          ctx.save();
          ctx.translate(
            this.x + Math.cos(angle) * dist,
            this.y + Math.sin(angle) * dist
          );
          ctx.rotate(Math.random() * Math.PI * 2);
          
          ctx.fillStyle = `rgba(200, 240, 255, ${this.lifetime / 60})`;
          ctx.beginPath();
          ctx.moveTo(0, -size/2);
          ctx.lineTo(size/3, 0);
          ctx.lineTo(0, size/2);
          ctx.lineTo(-size/3, 0);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }
        
        // Ice crystal effect at center
        ctx.save();
        ctx.translate(this.x, this.y);
        
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          ctx.save();
          ctx.rotate(angle);
          
          ctx.fillStyle = `rgba(200, 240, 255, ${this.lifetime / 60})`;
          ctx.beginPath();
          ctx.moveTo(0, -30);
          ctx.lineTo(10, -20);
          ctx.lineTo(0, -10);
          ctx.lineTo(-10, -20);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }
        
        ctx.restore();
      }
    }

    class LightningEffect {
      constructor(source, targets) {
        this.source = source;
        this.targets = targets;
        this.lifetime = 20;
        this.branches = [];
        
        // Create lightning branches between targets
        for (let i = 0; i < targets.length - 1; i++) {
          if (Math.random() < 0.7) {
            this.branches.push({
              from: targets[i],
              to: targets[i + 1]
            });
          }
        }
      }
      
      draw() {
        if (this.lifetime <= 0) return;
        this.lifetime--;
        
        const intensity = this.lifetime / 20;
        
        ctx.strokeStyle = `rgba(0, 200, 255, ${intensity})`;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'cyan';
        
        let lastX = this.source.x;
        let lastY = this.source.y;
        
        for (const target of this.targets) {
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          
          const steps = 8;
          const dx = (target.x - lastX) / steps;
          const dy = (target.y - lastY) / steps;
          
          for (let i = 1; i <= steps; i++) {
            const x = lastX + dx * i + (Math.random() * 20 - 10);
            const y = lastY + dy * i + (Math.random() * 20 - 10);
            ctx.lineTo(x, y);
          }
          
          ctx.stroke();
          
          // Draw lightning impact effect on target
          ctx.beginPath();
          ctx.arc(target.x, target.y, 15 * intensity, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(0, 200, 255, ${intensity * 0.5})`;
          ctx.fill();
          
          lastX = target.x;
          lastY = target.y;
        }
        
        // Draw branches
        for (const branch of this.branches) {
          ctx.beginPath();
          ctx.moveTo(branch.from.x, branch.from.y);
          
          const steps = 5;
          const dx = (branch.to.x - branch.from.x) / steps;
          const dy = (branch.to.y - branch.from.y) / steps;
          
          for (let i = 1; i <= steps; i++) {
            const x = branch.from.x + dx * i + (Math.random() * 15 - 7.5);
            const y = branch.from.y + dy * i + (Math.random() * 15 - 7.5);
            ctx.lineTo(x, y);
          }
          
          ctx.stroke();
        }
        
        ctx.shadowBlur = 0;
      }
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(20, 20, 250, 35);
      ctx.fillStyle = player.health > 50 ? (hellMode ? "#ff0000" : "#00ff88") : player.health > 20 ? "orange" : "red";
      ctx.fillRect(20, 20, 250 * (player.health / player.maxHealth), 35);
      ctx.strokeStyle = "white";
      ctx.strokeRect(20, 20, 250, 35);
      ctx.fillStyle = "white";
      ctx.font = "16px 'Press Start 2P', cursive";
      ctx.fillText(`VIDA: ${Math.floor(player.health)}/${player.maxHealth}`, 30, 45);
      
      let cooldownMax = 0;
      let cooldownCurrent = 0;
      let cooldownWidth = 0;
      
      switch(selectedSpecial) {
        case 'explosive': 
          cooldownMax = 600;
          cooldownCurrent = player.specialCooldowns.explosive;
          break;
        case 'multi': 
          cooldownMax = 420;
          cooldownCurrent = player.specialCooldowns.multi;
          break;
        case 'freeze': 
          cooldownMax = 780;
          cooldownCurrent = player.specialCooldowns.freeze;
          break;
        case 'lightning': 
          cooldownMax = 660;
          cooldownCurrent = player.specialCooldowns.lightning;
          break;
        case 'shield': 
          cooldownMax = 900;
          cooldownCurrent = player.specialCooldowns.shield;
          break;
        case 'meteor': 
          cooldownMax = 1200;
          cooldownCurrent = player.specialCooldowns.meteor;
          break;
      }
      
      cooldownWidth = 250 * (1 - cooldownCurrent / cooldownMax);
      
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(20, 70, 250, 25);
      ctx.fillStyle = cooldownWidth >= 250 ? "gold" : (hellMode ? "#ff5555" : "#00ffff");
      ctx.fillRect(20, 70, cooldownWidth, 25);
      ctx.strokeStyle = "white";
      ctx.strokeRect(20, 70, 250, 25);
      
      if (cooldownWidth >= 250) {
        ctx.fillStyle = "black";
        ctx.fillText("ESPECIAL PRONTO", 30, 90);
      }
      
      ctx.fillStyle = hellMode ? "#ff5555" : "#00ff88";
      ctx.font = "14px 'Press Start 2P', cursive";
      let specialName = "";
      switch(selectedSpecial) {
        case "explosive": specialName = "EXPLOSIVO"; break;
        case "multi": specialName = "CHUVA DE FLECHAS"; break;
        case "freeze": specialName = "CONGELAMENTO"; break;
        case "lightning": specialName = "REL√ÇMPAGO"; break;
        case "shield": specialName = "ESCUDO C√ìSMICO"; break;
        case "meteor": specialName = "ENCOMENDA DOS C√âUS"; break;
      }
      ctx.fillText(`PODER: ${specialName}`, 20, 120);
      
      if (player.shieldActive) {
        ctx.fillStyle = hellMode ? "rgba(255, 100, 100, 0.8)" : "rgba(0, 200, 255, 0.8)";
        ctx.fillText(`ESCUDO: ${Math.ceil(player.shieldTimer / 60)}s`, 20, 150);
      }
      
      if (player.slowTimer > 0) {
        ctx.fillStyle = "rgba(0, 200, 255, 0.8)";
        ctx.fillText(`LENTID√ÉO: ${Math.ceil(player.slowTimer / 60)}s`, 20, 180);
      }
      
      if (player.rapidFireActive) {
        ctx.fillStyle = hellMode ? "rgba(255, 150, 150, 0.8)" : "rgba(0, 255, 255, 0.8)";
        ctx.fillText(`TIRO R√ÅPIDO: ${Math.ceil(player.rapidFireTimer / 60)}s`, 20, 210);
      }
      
      if (player.burnTimer > 0) {
        ctx.fillStyle = "rgba(255, 100, 0, 0.8)";
        ctx.fillText(`QUEIMANDO: ${Math.ceil(player.burnTimer / 60)}s`, 20, 240);
      }
      
      ctx.fillStyle = hellMode ? "#ff5555" : "gold";
      ctx.textAlign = "right";
      ctx.fillText(`PONTOS: ${score}`, canvas.width - 30, 40);
      ctx.fillText(`RECORDE: ${highScore}`, canvas.width - 30, 70);
      
      if (player.combo > 1) {
        const comboAlpha = player.comboTimer / 60;
        ctx.fillStyle = `rgba(255, 255, 255, ${comboAlpha})`;
        ctx.fillText(`COMBO x${player.combo}!`, canvas.width - 30, 110);
      }
      ctx.textAlign = "left";
      
      if (player.dashCooldown > 0) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.fillText(`DASH: ${Math.ceil(player.dashCooldown / 60)}s`, 20, hellMode ? 270 : 240);
      }
    }

    function spawnEnemiesForWave(wave) {
      const count = 5 + wave * 3;
      const bossWave = wave % 5 === 0;
      const finalBossWave = wave === 15;
      const hellBossWave = wave === 20;
      
      enemies = [];
      bosses = [];
      
      if (player) {
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
      }
      
      if (hellBossWave) {
        bosses.push(new Enemy(9, wave));
        waveDisplay.textContent = `WAVE: ${wave} (DEVORADOR DE ALMAS)`;
      }
      else if (finalBossWave) {
        bosses.push(new Enemy(8, wave));
        waveDisplay.textContent = `WAVE: ${wave} (IMPERADOR DO MUNDO)`;
      } else if (bossWave) {
        if (wave === 5) {
          bosses.push(new Enemy(6, wave));
          waveDisplay.textContent = `WAVE: ${wave} (REI VIOLETA)`;
        } else if (wave === 10) {
          bosses.push(new Enemy(7, wave));
          waveDisplay.textContent = `WAVE: ${wave} (REI DOURADO)`;
        } else {
          bosses.push(new Enemy(6, wave));
          waveDisplay.textContent = `WAVE: ${wave} (REI VIOLETA)`;
        }
      } else {
        for (let i = 0; i < count; i++) {
          let type;
          const r = Math.random();
          
          if (wave < 3) {
            type = 1; 
          } else if (wave < 6) {
            type = r < 0.6 ? 1 : r < 0.85 ? 2 : 3;
          } else if (wave < 10) {
            type = r < 0.4 ? 1 : r < 0.7 ? 2 : r < 0.85 ? 3 : r < 0.95 ? 4 : 5;
          } else {
            type = r < 0.3 ? 1 : r < 0.6 ? 2 : r < 0.8 ? 3 : r < 0.9 ? 4 : 5;
          }
          
          enemies.push(new Enemy(type, wave));
        }
        waveDisplay.textContent = `WAVE: ${wave}`;
      }
      
      if (Math.random() < 0.4) {
        powerUps.push(new PowerUp());
      }
    }

    function showWaveStart(wave) {
      const waveText = wave === 20 ? "DEVORADOR DE ALMAS" : 
                      wave === 15 ? "IMPERADOR DO MUNDO" : 
                      wave === 10 ? "REI DOURADO" : 
                      wave === 5 ? "REI VIOLETA" : 
                      `WAVE ${wave}`;
      
      // Dark overlay
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Wave box
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(canvas.width / 2 - 200, canvas.height / 2 - 80, 400, 160);
      ctx.strokeStyle = hellMode ? "#ff0000" : "#00ff88";
      ctx.lineWidth = 5;
      ctx.strokeRect(canvas.width / 2 - 200, canvas.height / 2 - 80, 400, 160);
      
      // Wave text
      ctx.fillStyle = hellMode ? "#ff5555" : "#00ffff";
      ctx.font = "48px 'Bangers', cursive";
      ctx.textAlign = "center";
      ctx.fillText(waveText, canvas.width / 2, canvas.height / 2 - 20);
      
      ctx.font = "24px 'Press Start 2P', cursive";
      ctx.fillText("PREPARE-SE!", canvas.width / 2, canvas.height / 2 + 30);
      
      if (waveTimer < 180 && waveTimer > 0) {
        const count = Math.ceil(waveTimer / 60);
        ctx.font = "36px 'Press Start 2P', cursive";
        ctx.fillStyle = "gold";
        ctx.fillText(count.toString(), canvas.width / 2, canvas.height / 2 + 80);
      }
      
      ctx.textAlign = "start";
    }

    let player, arrows, enemies, bosses, powerUps, enemyProjectiles;
    let explosions, freezeEffects, lightningEffects, meteors, darkMeteors, lavaPatches;
    let currentWave, waveTimer, gameOver;

    function init() {
      player = new Player();
      arrows = [];
      enemies = [];
      bosses = [];
      powerUps = [];
      enemyProjectiles = [];
      explosions = [];
      freezeEffects = [];
      lightningEffects = [];
      meteors = [];
      darkMeteors = [];
      lavaPatches = [];
      
      if (hellMode) {
        currentWave = 16;
      } else {
        currentWave = 1;
      }
      
      waveTimer = 180;
      gameOver = false;
      
      spawnEnemiesForWave(currentWave);
      requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
      if (!gameActive) return;
      
      // Clear canvas with background effect
      if (hellMode) {
        ctx.fillStyle = '#290a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Hell background effect
        for (let i = 0; i < 30; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const size = Math.random() * 10 + 5;
          const alpha = Math.random() * 0.3 + 0.1;
          
          ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha})`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
      } else {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Star background effect
        ctx.fillStyle = "white";
        for (let i = 0; i < 150; i++) {
          const alpha = Math.random() * 0.8 + 0.2;
          const size = Math.random() * 3 + 1;
          ctx.globalAlpha = alpha;
          ctx.fillRect(
            Math.random() * canvas.width,
            Math.random() * canvas.height,
            size, size
          );
        }
        ctx.globalAlpha = 1;
      }

      if (player.health <= 0) {
        gameOver = true;
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = "red";
        ctx.font = "72px 'Bangers', cursive";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 50);
        
        ctx.font = "24px 'Press Start 2P', cursive";
        ctx.fillStyle = "white";
        ctx.fillText(`VOC√ä CHEGOU AT√â A WAVE ${currentWave}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText(`PONTUA√á√ÉO: ${score}`, canvas.width / 2, canvas.height / 2 + 60);
        
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('highScore', highScore);
          ctx.fillStyle = "gold";
          ctx.fillText("NOVO RECORDE!", canvas.width / 2, canvas.height / 2 + 100);
        }
        
        ctx.fillStyle = hellMode ? "#ff5555" : "#00ff88";
        ctx.fillText("CLIQUE PARA VOLTAR AO MENU", canvas.width / 2, canvas.height / 2 + 150);
        ctx.textAlign = "start";
        
        canvas.addEventListener('click', backToMenu, { once: true });
        return;
      }

      if (waveTimer > 0) {
        waveTimer--;
        showWaveStart(currentWave);
        
        requestAnimationFrame(gameLoop);
        return;
      }

      player.update();
      player.draw();

      arrows = arrows.filter(a => a.alive);
      arrows.forEach(a => { a.update(); a.draw(); });

      enemies.forEach(e => {
        e.update();
        e.draw();
        
        if (Math.hypot(player.x - e.x, player.y - e.y) < player.radius + e.radius) {
          player.takeDamage(e.damage);
        }
        
        // Check if enemy is in lava
        lavaPatches.forEach(lava => {
          if (Math.hypot(e.x - lava.x, e.y - lava.y) < e.radius + lava.radius) {
            e.applyBurn(5); // 5 seconds burn
          }
        });
      });

      bosses.forEach(b => {
        b.update();
        b.draw();
        
        if (Math.hypot(player.x - b.x, player.y - b.y) < player.radius + b.radius) {
          player.takeDamage(b.damage);
        }
        
        // Check if boss is in lava
        lavaPatches.forEach(lava => {
          if (Math.hypot(b.x - lava.x, b.y - lava.y) < b.radius + lava.radius) {
            b.applyBurn(5); // 5 seconds burn
          }
        });
      });

      enemyProjectiles = enemyProjectiles.filter(p => p.alive);
      enemyProjectiles.forEach(p => {
        p.update();
        p.draw();
        
        if (Math.hypot(player.x - p.x, player.y - p.y) < player.radius + p.radius) {
          player.takeDamage(p.damage);
          
          if (p.burning) {
            player.applyBurn(3); 
          }
          
          p.alive = false;
        }
      });

      powerUps = powerUps.filter(p => p.lifetime > 0);
      powerUps.forEach((p, i) => {
        p.draw();
        
        if (Math.hypot(player.x - p.x, player.y - p.y) < player.radius + p.radius) {
          switch(p.type) {
            case "heal":
              player.health = Math.min(player.maxHealth, player.health + 40);
              break;
            case "rapid":
              player.rapidFireActive = true;
              player.rapidFireTimer = 240;
              break;
            case "special":
              for (const key in player.specialCooldowns) {
                player.specialCooldowns[key] = Math.max(0, player.specialCooldowns[key] - 150);
              }
              break;
            case "shield":
              player.shieldActive = true;
              player.shieldTimer = 180;
              break;
            case "maxhp":
              player.maxHealth += 15;
              player.health += 15;
              break;
          }
          powerUps.splice(i, 1);
        }
      });

      meteors = meteors.filter(m => m.isActive());
      meteors.forEach(m => {
        m.update();
        m.draw();
      });

      darkMeteors = darkMeteors.filter(m => m.isActive());
      darkMeteors.forEach(m => {
        m.update();
        m.draw();
      });

      lavaPatches = lavaPatches.filter(p => p.lifetime > 0);
      lavaPatches.forEach(p => {
        p.lifetime--;
        
        // Draw lava patch with animation
        const pulse = Math.sin(Date.now() / 200) * 5;
        const gradient = ctx.createRadialGradient(
          p.x, p.y, 0,
          p.x, p.y, p.radius + pulse
        );
        gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 50, 0, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius + pulse, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw lava bubbles
        for (let i = 0; i < 3; i++) {
          const bubbleX = p.x + Math.random() * p.radius * 2 - p.radius;
          const bubbleY = p.y + Math.random() * p.radius * 2 - p.radius;
          const bubbleSize = Math.random() * 8 + 2;
          
          if (Math.hypot(bubbleX - p.x, bubbleY - p.y) < p.radius) {
            ctx.fillStyle = `rgba(255, 255, 200, ${Math.random() * 0.5 + 0.3})`;
            ctx.beginPath();
            ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }
       
        if (Math.hypot(player.x - p.x, player.y - p.y) < player.radius + p.radius) {
          player.slowTimer = 18;
          if (p.lifetime % 60 === 0) { 
            player.takeDamage(10);
          }
        }
      });

      arrows.forEach(a => {
        enemies.forEach((e, ei) => {
          if (Math.hypot(a.x - e.x, a.y - e.y) < e.radius) {
            e.takeDamage(a.damage);
            
            score += e.scoreValue * (1 + player.combo * 0.1);
            
            if (e.health <= 0) {
              player.kills++;
              if (Math.random() < 0.05) {
                powerUps.push(new PowerUp());
              }
            }
            
            if (a.pierce <= 0) {
              a.alive = false;
            } else {
              a.pierce--;
            }
          }
        });
        
        bosses.forEach(b => {
          if (Math.hypot(a.x - b.x, a.y - b.y) < b.radius) {
            b.takeDamage(a.damage * 0.6);
            
            if (b.health <= 0) {
              score += b.scoreValue * (1 + player.combo * 0.2);
            }
            
            if (a.pierce <= 0) {
              a.alive = false;
            } else {
              a.pierce--;
            }
          }
        });
      });

      enemies = enemies.filter(e => e.health > 0);
      bosses = bosses.filter(b => b.health > 0);

      explosions = explosions.filter(e => e.lifetime > 0);
      explosions.forEach(e => { e.update(); e.draw(); });
      
      freezeEffects = freezeEffects.filter(f => f.lifetime > 0);
      freezeEffects.forEach(f => { f.update(); f.draw(); });
      
      lightningEffects = lightningEffects.filter(l => l.lifetime > 0);
      lightningEffects.forEach(l => l.draw());

      if (enemies.length === 0 && bosses.length === 0 && waveTimer <= 0) {
        currentWave++;
        
        if (currentWave > 20) {
          hellVictoryScreen.style.display = 'flex';
          
          if (score > highScore) {
            highScore = score;
            localStorage.setItem('highScore', highScore);
          }
          return;
        }
        else if (currentWave > 15 && !hellMode) {
          victoryScreen.style.display = 'flex';
          
          if (score > highScore) {
            highScore = score;
            localStorage.setItem('highScore', highScore);
          }
          return;
        }
        
        waveTimer = 180;
        spawnEnemiesForWave(currentWave);
      }

      drawHUD();
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>