<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Arqueiro Lend√°rio</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&display=swap');
    
    body {
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      margin: 0;
      overflow: hidden;
      color: white;
      font-family: 'Press Start 2P', cursive;
      text-align: center;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      user-select: none;
    }
    
    canvas {
      display: none;
      background: #111;
      margin: 20px auto;
      border-radius: 10px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      border: 2px solid #00ffff;
    }
    
    #menu {
      background: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      max-width: 700px;
      margin: 0 auto;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.4);
      border: 3px solid #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 200, 0.5);
    }
    
    h1 {
      color: #00ff88;
      text-shadow: 0 0 15px rgba(0, 255, 150, 0.7);
      margin-bottom: 30px;
      font-size: 3em;
      font-family: 'Bangers', cursive;
      letter-spacing: 3px;
    }
    
    .power-options {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 25px;
      margin-bottom: 30px;
    }
    
    .power-option {
      background: rgba(20, 20, 40, 0.9);
      padding: 20px;
      border-radius: 15px;
      width: 160px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .power-option:hover {
      transform: translateY(-8px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
      border-color: #00ff88;
    }
    
    .power-option.selected {
      border-color: #00ff88;
      background: rgba(0, 255, 150, 0.15);
      box-shadow: 0 0 20px rgba(0, 255, 150, 0.3);
    }
    
    .power-option .character-icon {
      font-size: 50px;
      margin-bottom: 15px;
      filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.7));
    }
    
    .power-option div:not(.character-icon) {
      margin: 5px 0;
    }
    
    .power-description {
      font-size: 0.7em;
      color: #aaa;
      margin-top: 10px;
      line-height: 1.4;
      font-family: 'Arial', sans-serif;
    }
    
    button {
      background: linear-gradient(135deg, #00ff88, #007544);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 1.3em;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      margin-top: 20px;
      font-family: 'Press Start 2P', cursive;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      letter-spacing: 1px;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      background: linear-gradient(135deg, #00e67b, #00633a);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    #victory-screen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
    }
    
    #victory-screen h1 {
      color: gold;
      font-size: 5em;
      text-shadow: 0 0 30px gold;
      margin-bottom: 30px;
      animation: pulse 2s infinite;
      font-family: 'Bangers', cursive;
    }
    
    #victory-screen p {
      font-size: 1.5em;
      margin-bottom: 40px;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 150, 0.5);
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    #wave-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 12px 25px;
      border-radius: 25px;
      font-size: 1.3em;
      border: 2px solid #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 150, 0.3);
      text-shadow: 0 0 5px rgba(0, 255, 150, 0.5);
    }
    
    #controls {
      margin-top: 30px;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid #00ffff;
    }
    
    #controls h3 {
      color: #00ffff;
      margin-bottom: 10px;
      font-size: 1em;
    }
    
    #controls p {
      font-size: 0.7em;
      margin: 5px 0;
      font-family: 'Arial', sans-serif;
    }
    
    .particle {
      position: absolute;
      background: white;
      border-radius: 50%;
      pointer-events: none;
    }
    
    #loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0f0c29;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    #loading-bar {
      width: 300px;
      height: 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      margin-top: 20px;
      overflow: hidden;
      border: 2px solid #00ff88;
    }
    
    #loading-progress {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00ff88, #00ffff);
      transition: width 0.3s;
    }
    
    #loading-text {
      margin-top: 15px;
      color: #00ff88;
      font-size: 0.8em;
    }
  </style>
</head>
<body>
  <div id="loading-screen">
    <h1 style="color: #00ff88; font-size: 3em;">ARQUEIRO LEND√ÅRIO</h1>
    <div id="loading-bar">
      <div id="loading-progress"></div>
    </div>
    <div id="loading-text">Carregando recursos...</div>
  </div>

  <div id="menu">
    <h1>ARQUEIRO LEND√ÅRIO</h1>
    <div class="power-options">
      <div class="power-option selected" onclick="selectPower('explosive')">
       <div class="character-icon">üí•</div>
        <div>EXPLOSIVO</div>
        <div class="power-description">Cria uma explos√£o poderosa que causa dano em √°rea e empurra inimigos!</div>
      </div>
      <div class="power-option" onclick="selectPower('multi')">
        <div class="character-icon">üèπ</div>
        <div>CHUVA DE FLECHAS</div>
        <div class="power-description">Dispara 14 flechas de uma vez, atingindo todos os inimigos a sua frente!</div>
      </div>
      <div class="power-option" onclick="selectPower('freeze')">
        <div class="character-icon">‚ùÑÔ∏è</div>
        <div>CONGELAMENTO</div>
        <div class="power-description">Deixa seus inimigos com um resfriado, todos eles ficam muito lentos por alguns segundos!</div>
      </div>
      <div class="power-option" onclick="selectPower('lightning')">
       <div class="character-icon">‚ö°</div>
        <div>REL√ÇMPAGO</div>
        <div class="power-description">Eletrocuta at√© 12 inimigos pr√≥ximos, deixando-os paralisados por 0.5s!</div>
      </div>
      <div class="power-option" onclick="selectPower('shield')">
        <div class="character-icon">üî∞</div>
        <div>ESCUDO C√ìSMICO</div>
        <div class="power-description">Cria um escudo de invencibilidade tempor√°rio!</div>
      </div>
      <div class="power-option" onclick="selectPower('meteor')">
        <div class="character-icon">‚òÑÔ∏è</div>
        <div>ENCOMENDA DOS C√âUS</div>
        <div class="power-description">Meteoros esmagam seus inimigos e deixam o ch√£o em chamas!</div>
      </div>
    </div>
    <button onclick="startGame()">COME√áAR JOGO</button>
    
    <div id="controls">
      <h3>CONTROLES</h3>
      <p>WASD - Movimento | Mouse - Mirar e Atirar | E - Habilidade Especial</p>
      <p>Colete power-ups para ganhar vantagens durante a batalha!</p>
    </div>
  </div>
  
  <canvas id="gameCanvas" width="1000" height="750"></canvas>
  
  <div id="wave-display" style="display: none;">WAVE: 1</div>
  
  <div id="victory-screen">
    <h1>VIT√ìRIA LEND√ÅRIA!</h1>
    <p>Voc√™ provou ser capaz de superar seus limites, agora teste outros poderes!</p>
    <button onclick="backToMenu()">JOGAR NOVAMENTE</button>
  </div>
  
  <script>
    function createMenuParticles() {
      const colors = ['#00ff88', '#00ffff', '#ff00ff', '#ffff00'];
      for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        const size = Math.random() * 5 + 2;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        particle.style.opacity = Math.random() * 0.5 + 0.1;
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        
        document.body.appendChild(particle);
        
        setInterval(() => {
          particle.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
        }, Math.random() * 2000 + 1000);
      }
    }
    
    function simulateLoading() {
      let progress = 0;
      const loadingInterval = setInterval(() => {
        progress += Math.random() * 10 + 5;
        if (progress >= 100) {
          progress = 100;
          clearInterval(loadingInterval);
          setTimeout(() => {
            document.getElementById('loading-screen').style.display = 'none';
            createMenuParticles();
          }, 500);
        }
        document.getElementById('loading-progress').style.width = `${progress}%`;
        document.getElementById('loading-text').textContent = 
          progress < 30 ? "Carregando recursos..." :
          progress < 70 ? "Preparando inimigos..." :
          "Quase l√°...";
      }, 200);
    }
    
    simulateLoading();

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const waveDisplay = document.getElementById('wave-display');
    const victoryScreen = document.getElementById('victory-screen');

    let keys = {}, mouse = { x: 0, y: 0, clicked: false };
    let selectedSpecial = 'explosive';
    let gameActive = false;
    let score = 0;
    let highScore = localStorage.getItem('highScore') || 0;

    const sounds = {
      shoot: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      explosion: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      freeze: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      lightning: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      shield: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      powerup: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      enemyHit: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      playerHit: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      victory: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      gameOver: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'),
      meteor: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...')
    };

    Object.values(sounds).forEach(sound => {
      sound.volume = 0.3;
    });

    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('mousedown', () => mouse.clicked = true);
    canvas.addEventListener('mouseup', () => mouse.clicked = false);

    function selectPower(power) {
      selectedSpecial = power;
      document.querySelectorAll('.power-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      event.currentTarget.classList.add('selected');
      sounds.powerup.play();
    }

    function startGame() {
      document.getElementById('menu').style.display = 'none';
      canvas.style.display = 'block';
      waveDisplay.style.display = 'block';
      gameActive = true;
      score = 0;
      init();
    }

    function backToMenu() {
      victoryScreen.style.display = 'none';
      document.getElementById('menu').style.display = 'block';
      canvas.style.display = 'none';
      waveDisplay.style.display = 'none';
      gameActive = false;
    }

    class Player {
      constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.speed = 5;
        this.radius = 25;
        this.health = 150;
        this.maxHealth = 150;
        this.shootCooldown = 0;
        this.specialCooldown = 0;
        this.shieldActive = false;
        this.shieldTimer = 0;
        this.slowTimer = 0;
        this.originalSpeed = this.speed;
        this.dashCooldown = 0;
        this.dashing = false;
        this.dashTimer = 0;
        this.invulnerable = false;
        this.kills = 0;
        this.combo = 0;
        this.comboTimer = 0;
        this.rapidFireTimer = 0;
        this.rapidFireActive = false;
        this.specialCooldowns = {
          explosive: 0,
          multi: 0,
          freeze: 0,
          lightning: 0,
          shield: 0,
          meteor: 0
        };
      }

      update() {
        if (this.slowTimer > 0) {
          this.slowTimer--;
          this.speed = this.originalSpeed * 0.5;
        } else {
          this.speed = this.originalSpeed;
        }

        if (this.rapidFireActive) {
          this.rapidFireTimer--;
          if (this.rapidFireTimer <= 0) {
            this.rapidFireActive = false;
          }
        }

        if (keys["Space"] && this.dashCooldown <= 0 && !this.dashing) {
          this.dashing = true;
          this.dashTimer = 15;
          this.dashCooldown = 120;
          this.invulnerable = true;
          this.speed *= 3;
          sounds.shield.play();
        }

        if (this.dashing) {
          this.dashTimer--;
          if (this.dashTimer <= 0) {
            this.dashing = false;
            this.invulnerable = false;
            this.speed = this.originalSpeed;
          }
        }

        if (this.dashCooldown > 0) this.dashCooldown--;

        if (keys["KeyW"]) this.y -= this.speed;
        if (keys["KeyS"]) this.y += this.speed;
        if (keys["KeyA"]) this.x -= this.speed;
        if (keys["KeyD"]) this.x += this.speed;
        
        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

        const shootSpeed = this.rapidFireActive ? 6 : 10;
        if (mouse.clicked && this.shootCooldown <= 0) {
          const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
          arrows.push(new Arrow(this.x, this.y, angle));
          this.shootCooldown = shootSpeed;
          sounds.shoot.play();
          
          this.combo++;
          this.comboTimer = 20; 
        }

        if (this.shootCooldown > 0) this.shootCooldown--;
        
        // Update all special cooldowns
        for (const key in this.specialCooldowns) {
          if (this.specialCooldowns[key] > 0) {
            this.specialCooldowns[key]--;
          }
        }

        if (this.comboTimer > 0) this.comboTimer--;
       
        if (keys["KeyE"] && this.specialCooldowns[selectedSpecial] <= 0) {
          useSpecial(this);
          // Set cooldown based on power type
          switch(selectedSpecial) {
            case 'explosive': this.specialCooldowns.explosive = 600; break; // 10 segundos
            case 'multi': this.specialCooldowns.multi = 420; break; // 7 segundos
            case 'freeze': this.specialCooldowns.freeze = 780; break; // 13 segundos
            case 'lightning': this.specialCooldowns.lightning = 660; break; // 11 segundos
            case 'shield': this.specialCooldowns.shield = 900; break; // 15 segundos
            case 'meteor': this.specialCooldowns.meteor = 1200; break; // 20 segundos
          }
        }

        if (this.shieldActive) {
          this.shieldTimer--;
          if (this.shieldTimer <= 0) {
            this.shieldActive = false;
          }
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        ctx.rotate(angle);
        
        if (this.dashing) {
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(0, 200, 255, 0.3)';
          ctx.fill();
        }
        
        if (this.shieldActive) {
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 15, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)';
          ctx.lineWidth = 4;
          ctx.stroke();
          
          for (let i = 0; i < 8; i++) {
            const shieldAngle = (Date.now() / 200 + i * Math.PI / 4) % (Math.PI * 2);
            ctx.beginPath();
            ctx.arc(
              Math.cos(shieldAngle) * (this.radius + 10),
              Math.sin(shieldAngle) * (this.radius + 10),
              3, 0, Math.PI * 2
            );
            ctx.fillStyle = 'rgba(0, 200, 255, 0.8)';
            ctx.fill();
          }
        }
        
        ctx.fillStyle = this.invulnerable ? "#00ffff" : "#00ff88";
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(0, -7, 40, 14);
        
        ctx.fillStyle = this.invulnerable ? "#00aaff" : "#00aa77";
        ctx.beginPath();
        ctx.arc(0, 0, this.radius - 8, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(10, -8, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(10, 8, 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(12, -8, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(12, 8, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      takeDamage(amount) {
        if (!this.shieldActive && !this.invulnerable) {
          this.health -= amount;
          sounds.playerHit.play();
          
          this.combo = 0;
          this.comboTimer = 0;
          
          ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }
    }

    class Arrow {
      constructor(x, y, angle, specialEffect = null) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 12;
        this.dx = Math.cos(angle) * this.speed;
        this.dy = Math.sin(angle) * this.speed;
        this.alive = true;
        this.specialEffect = specialEffect;
        this.lifetime = 120;
        this.damage = 25;
        this.pierce = 0;
        
        if (specialEffect === 'lightning') {
          this.damage = 40;
          this.pierce = 2;
        } else if (specialEffect === 'explosive') {
          this.damage = 35;
        }
      }

      update() {
        this.x += this.dx;
        this.y += this.dy;
        this.lifetime--;
        
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.lifetime <= 0) {
          this.alive = false;
          
          if (this.specialEffect === 'explosive') {
            explosions.push(new Explosion(this.x, this.y, 72)); // Aumentado em 20% (60 -> 72)
          }
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        if (this.specialEffect === 'lightning') {
          // Lightning arrow
          ctx.fillStyle = "gold";
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(25, 0);
          ctx.stroke();
          
          for (let i = 0; i < 6; i++) {
            const offset = Math.random() * 6 - 3;
            ctx.beginPath();
            ctx.moveTo(i * 4, offset);
            ctx.lineTo((i + 1) * 4, offset + (Math.random() * 6 - 3));
            ctx.strokeStyle = "cyan";
            ctx.stroke();
          }
          
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 150, 0.3)';
          ctx.fill();
        } else if (this.specialEffect === 'explosive') {
          const gradient = ctx.createLinearGradient(0, -5, 25, 0);
          gradient.addColorStop(0, 'red');
          gradient.addColorStop(0.5, 'orange');
          gradient.addColorStop(1, 'yellow');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, -4, 25, 8);
          
          ctx.beginPath();
          ctx.arc(25, 0, 5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 100, 0, 0.7)';
          ctx.fill();
        } else {
          const gradient = ctx.createLinearGradient(0, -3, 25, 0);
          gradient.addColorStop(0, '#00ff88');
          gradient.addColorStop(1, '#00ffff');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, -3, 25, 6);
          
          ctx.beginPath();
          ctx.moveTo(25, 0);
          ctx.lineTo(20, -4);
          ctx.lineTo(20, 4);
          ctx.closePath();
          ctx.fillStyle = 'silver';
          ctx.fill();
          
          ctx.fillStyle = '#ff00ff';
          ctx.beginPath();
          ctx.moveTo(0, -3);
          ctx.lineTo(-5, -6);
          ctx.lineTo(-5, 0);
          ctx.closePath();
          ctx.fill();
          
          ctx.fillStyle = '#00ffff';
          ctx.beginPath();
          ctx.moveTo(0, 3);
          ctx.lineTo(-5, 6);
          ctx.lineTo(-5, 0);
          ctx.closePath();
          ctx.fill();
        }
        
        ctx.restore();
      }
    }

    class Enemy {
      constructor(type = 1, wave = 1) {
        this.type = type;
        this.wave = wave;
        
        if (Math.random() < 0.5) {
          this.x = Math.random() < 0.5 ? 0 : canvas.width;
          this.y = Math.random() * canvas.height;
        } else {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() < 0.5 ? 0 : canvas.height;
        }
        
        switch(type) {
          case 1:
            this.radius = 18;
            this.speed = 2.5 + wave * 0.07;
            this.health = 40 + wave * 3;
            this.color = "#ff5555";
            this.damage = 0.5;
            this.scoreValue = 10;
            break;
          case 2: 
            this.radius = 22;
            this.speed = 2 + wave * 0.05;
            this.health = 100 + wave * 6;
            this.color = "#aa0000";
            this.damage = 0.8;
            this.scoreValue = 25;
            break;
          case 3: 
            this.radius = 15;
            this.speed = 3.6 + wave * 0.09; // 10% mais devagar (4 -> 3.6)
            this.health = 30 + wave * 2;
            this.color = "#ffaa00";
            this.damage = 0.3;
            this.scoreValue = 15;
            break;
          case 4: 
            this.radius = 30;
            this.speed = 1.2 + wave * 0.03;
            this.health = 200 + wave * 10;
            this.color = "#5555ff";
            this.damage = 1.2;
            this.scoreValue = 40;
            break;
          case 5:
            this.radius = 20;
            this.speed = 2 + wave * 0.06;
            this.health = 70 + wave * 4;
            this.color = "#aa00aa";
            this.damage = 0.6;
            this.shootCooldown = 0;
            this.shootingRange = 300;
            this.scoreValue = 30;
            break;
          case 6: // Wave 5 Boss
            this.radius = 45;
            this.speed = player.speed * 0.85;
            this.health = 500 + wave * 40;
            this.color = "#ff00ff";
            this.damage = 2;
            this.shootCooldown = 0;
            this.fireTrailCooldown = 0;
            this.fireTrails = [];
            this.scoreValue = 200;
            break;
          case 7: // Wave 10 Boss
            this.radius = 45;
            this.speed = player.speed * 0.75;
            this.health = (500 + wave * 40) * 1.4;
            this.color = "#ffff00";
            this.damage = 2;
            this.shootCooldown = 0;
            this.specialCooldown = 0;
            this.scoreValue = 400;
            break;
          case 8: // Final Boss
            this.radius = 70;
            this.speed = player.speed * 0.8;
            this.health = (500 + wave * 40) * 2;
            this.color = "#ff4500";
            this.damage = 3;
            this.shootCooldown = 0;
            this.minionCooldown = 0;
            this.phase = 1;
            this.auraActive = false;
            this.scoreValue = 1000;
            break;
        }
        
        this.maxHealth = this.health;
        this.originalSpeed = this.speed;
        this.slowTimer = 0;
        this.hitFlash = 0;
        this.stunnedTimer = 0;
      }

      update() {
        if (this.stunnedTimer > 0) {
          this.stunnedTimer--;
          return;
        }

        if (this.slowTimer > 0) {
          this.slowTimer--;
          this.speed = this.originalSpeed * 0.3;
        } else {
          this.speed = this.originalSpeed;
        }
        
        if (this.hitFlash > 0) this.hitFlash--;

        if (this.type === 5) { // Inimigo roxo (atirador)
          const distanceToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
          
          if (distanceToPlayer > this.shootingRange) {
            // Move towards player
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;
          } else {
            // Stop and shoot
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle, this.type));
              this.shootCooldown = 100;
            }
          }
        }
        else if (this.type === 6 || this.type === 7 || this.type === 8) {
          const angle = Math.atan2(player.y - this.y, player.x - this.x);
          this.x += Math.cos(angle) * this.speed;
          this.y += Math.sin(angle) * this.speed;
          
          if (this.type === 6) { 
            this.fireTrailCooldown--;
            if (this.fireTrailCooldown <= 0) {
              this.fireTrails.push(new FireTrail(this.x, this.y));
              this.fireTrailCooldown = 50; 
            }
            
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle, this.type));
              this.shootCooldown = 20;
            }
          }
          else if (this.type === 7) {
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              for (let i = -1; i <= 1; i++) {
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle + (i * 0.3), this.type));
              }
              this.shootCooldown = 80;
            }
            
            this.specialCooldown--;
            if (this.specialCooldown <= 0) {
              for (let i = 0; i < 36; i++) {
                const angle = (i / 36) * Math.PI * 2;
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angle, 'energy'));
              }
              this.specialCooldown = 500;
            }
          }
          else if (this.type === 8) { 
            if (this.health < this.maxHealth / 2 && this.phase === 1) {
              this.phase = 2;
              this.color = "#ff0000";
              this.damage *= 1.5;
              this.auraActive = true;
              this.speed *= 1.2;
            }
            
            this.minionCooldown--;
            const minionInterval = this.phase === 1 ? 200 : 120; // 3.3s or 2s
            if (this.minionCooldown <= 0) {
              enemies.push(new Enemy(1, this.wave + 5));
              enemies.push(new Enemy(3, this.wave + 5));
              this.minionCooldown = minionInterval;
            }
            
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              for (let i = 0; i < 12; i++) {
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle + (i * Math.PI / 6), this.type));
              }
              this.shootCooldown = 40;
            }
          }
          
          if (this.shootCooldown > 0) this.shootCooldown--;
        } else {
          // Move towards player
          const angle = Math.atan2(player.y - this.y, player.x - this.x);
          this.x += Math.cos(angle) * this.speed;
          this.y += Math.sin(angle) * this.speed;
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.hitFlash > 0) {
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        switch(this.type) {
          case 2: // armadurado
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.beginPath();
            ctx.arc(0, 0, this.radius - 8, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 3: // rapido
            ctx.strokeStyle = "yellow";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
            break;
          case 4: // tank
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.beginPath();
            ctx.arc(0, 0, this.radius - 10, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 5: // atirador
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 6: // Wave 5 Boss
          case 7: // Wave 10 Boss
          case 8: // boss final
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            ctx.rotate(angle);
            
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(15, -10, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(15, 10, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(18, -10, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(18, 10, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(10, 0, 5, 0, Math.PI);
            ctx.fill();
        }
        
        ctx.restore();
        
        if (this.type === 6 || this.type === 7 || this.type === 8) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 20, this.radius * 2, 8);
          ctx.fillStyle = this.health > this.maxHealth / 2 ? "lime" : "red";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 20, this.radius * 2 * (this.health / this.maxHealth), 8);
          ctx.strokeStyle = "white";
          ctx.strokeRect(this.x - this.radius, this.y - this.radius - 20, this.radius * 2, 8);
          
          ctx.fillStyle = "white";
          ctx.font = "18px 'Press Start 2P', cursive";
          ctx.textAlign = "center";
          if (this.type === 6) {
            ctx.fillText("BOSS VIOLETA", this.x, this.y - this.radius - 35);
          } else if (this.type === 7) {
            ctx.fillText("BOSS DOURADO", this.x, this.y - this.radius - 35);
          } else if (this.type === 8) {
            ctx.fillText("BOSS FINAL", this.x, this.y - this.radius - 35);
            
            if (this.auraActive) {
              ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
              ctx.lineWidth = 8;
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.radius + 25, 0, Math.PI * 2);
              ctx.stroke();
            }
          }
          ctx.textAlign = "start";
        }
        
        if (this.type === 6) {
          this.fireTrails = this.fireTrails.filter(trail => trail.lifetime > 0);
          this.fireTrails.forEach(trail => {
            trail.update();
            trail.draw();
          });
        }
      }
      
      takeDamage(amount) {
        this.health -= amount;
        this.hitFlash = 3;
        sounds.enemyHit.play();
      }
      
      stun(duration) {
        this.stunnedTimer = duration;
      }
    }

    class FireTrail {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 60;
        this.lifetime = 240; 
        this.damage = 0.8;
      }
      
      update() {
        this.lifetime--;
        this.radius = 60 * (this.lifetime / 240);
      }
      
      draw() {
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, 'rgba(255, 150, 0, 0.8)');
        gradient.addColorStop(0.7, 'rgba(255, 50, 0, 0.4)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        if (Math.hypot(player.x - this.x, player.y - this.y) < player.radius + this.radius) {
          if (!player.shieldActive && !player.invulnerable) {
            player.takeDamage(this.damage);
          }
        }
      }
    }

    class EnemyProjectile {
      constructor(x, y, angle, enemyType) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.enemyType = enemyType;
        
        if (enemyType === 'energy') {
          this.speed = 3.5;
          this.damage = 25;
          this.radius = 10;
          this.color = "cyan";
          this.isEnergyBall = true;
          this.homing = false;
        } else {
          this.speed = enemyType === 7 ? 6 : enemyType === 6 ? 7 : 5;
          this.damage = enemyType === 7 ? 10 : enemyType === 6 ? 15 : 8;
          this.radius = enemyType === 7 ? 8 : enemyType === 6 ? 10 : 6;
          this.color = enemyType === 7 ? "yellow" : enemyType === 6 ? "purple" : "orange";
          this.isEnergyBall = false;
          this.homing = enemyType === 8;
        }
        
        this.alive = true;
        this.homingPower = 0.05;
      }

      update() {
        if (this.homing) {
          const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
          const angleDiff = ((targetAngle - this.angle + 3 * Math.PI) % (2 * Math.PI)) - Math.PI;
          this.angle += Math.min(this.homingPower, Math.max(-this.homingPower, angleDiff));
        }
        
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
          this.alive = false;
        }
      }

      draw() {
        if (this.isEnergyBall) {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2);
          const gradient = ctx.createRadialGradient(
            this.x, this.y, 0,
            this.x, this.y, this.radius + 10
          );
          gradient.addColorStop(0, 'rgba(0, 255, 255, 0.5)');
          gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
          ctx.fillStyle = gradient;
          ctx.fill();
        } else {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.x - Math.cos(this.angle) * 15, this.y - Math.sin(this.angle) * 15);
          ctx.lineTo(this.x, this.y);
          ctx.stroke();
        }
      }
    }

    class PowerUp {
      constructor(type = null) {
        this.x = Math.random() * (canvas.width - 100) + 50;
        this.y = Math.random() * (canvas.height - 100) + 50;
        this.radius = 20;
        this.type = type || this.getRandomType();
        this.lifetime = 600; // 10 segundos
        this.floatOffset = Math.random() * Math.PI * 2;
        this.floatSpeed = Math.random() * 0.05 + 0.05;
        this.originalY = this.y;
      }
      
      getRandomType() {
        const r = Math.random();
        if (r < 0.35) return "heal";
        if (r < 0.6) return "rapid";
        if (r < 0.8) return "special";
        if (r < 0.9) return "shield";
        return "maxhp";
      }

      update() {
        this.floatOffset += this.floatSpeed;
        this.y = this.originalY + Math.sin(this.floatOffset) * 10;
        this.lifetime--;
      }

      draw() {
        this.update();
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius + 5);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fill();
        
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.beginPath();
        ctx.arc(0, 0, this.radius - 3, 0, Math.PI * 2);
        ctx.fill();
        
        switch(this.type) {
          case "heal":
            ctx.fillStyle = "lime";
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(8, 8);
            ctx.lineTo(-8, 8);
            ctx.closePath();
            ctx.fill();
            break;
          case "rapid":
            ctx.fillStyle = "cyan";
            ctx.fillRect(-10, -4, 20, 8);
            ctx.fillRect(-4, -10, 8, 20);
            break;
          case "special":
            ctx.fillStyle = "gold";
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "rgba(255, 255, 0, 0.7)";
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              ctx.beginPath();
              ctx.arc(
                Math.cos(angle) * 15,
                Math.sin(angle) * 15,
                3, 0, Math.PI * 2
              );
              ctx.fill();
            }
            break;
          case "shield":
            ctx.strokeStyle = "rgba(0, 200, 255, 0.8)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(8, 0);
            ctx.lineTo(0, 8);
            ctx.lineTo(-8, 0);
            ctx.closePath();
            ctx.stroke();
            break;
          case "maxhp":
            ctx.fillStyle = "pink";
            ctx.beginPath();
            ctx.arc(0, -8, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, 8, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(-6, -2, 12, 12);
            break;
        }
        
        ctx.restore();
      }
    }

    class Meteor {
      constructor(targetX, targetY) {
        this.x = Math.random() * canvas.width;
        this.y = -100;
        this.targetX = targetX;
        this.targetY = targetY;
        this.speed = 15;
        this.radius = 30;
        this.damage = 54; // 40% do dano da explos√£o (135 * 0.4)
        this.impacted = false;
        this.fireDuration = 180; // 3 segundos
        this.fireRadius = 80;
      }
      
      update() {
        if (!this.impacted) {
          // Move towards target
          const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
          this.x += Math.cos(angle) * this.speed;
          this.y += Math.sin(angle) * this.speed;
          
          // Check if reached target
          if (Math.hypot(this.targetX - this.x, this.targetY - this.y) < 10) {
            this.impacted = true;
            sounds.explosion.play();
            
            // Damage enemies in radius
            [...enemies, ...bosses].forEach(e => {
              const dist = Math.hypot(this.x - e.x, this.y - e.y);
              if (dist < this.radius + e.radius) {
                e.takeDamage(this.damage);
              }
            });
          }
        } else {
          this.fireDuration--;
        }
      }
      
      draw() {
        if (!this.impacted) {
          // Draw falling meteor
          ctx.save();
          ctx.translate(this.x, this.y);
          
          // Meteor core
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
          gradient.addColorStop(0, 'orange');
          gradient.addColorStop(0.7, 'red');
          gradient.addColorStop(1, 'darkred');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Meteor trail
          ctx.strokeStyle = 'rgba(255, 165, 0, 0.7)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-this.speed * 2, -this.speed * 3);
          ctx.stroke();
          
          ctx.restore();
        } else if (this.fireDuration > 0) {
          // Draw fire effect
          const gradient = ctx.createRadialGradient(
            this.x, this.y, 0,
            this.x, this.y, this.fireRadius
          );
          gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
          gradient.addColorStop(0.7, 'rgba(255, 50, 0, 0.4)');
          gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.fireRadius * (this.fireDuration / 180), 0, Math.PI * 2);
          ctx.fill();
          
          // Damage enemies in fire
          if (this.fireDuration % 10 === 0) { // Damage every 10 frames
            [...enemies, ...bosses].forEach(e => {
              const dist = Math.hypot(this.x - e.x, this.y - e.y);
              if (dist < this.fireRadius) {
                e.takeDamage(5); // Burn damage
              }
            });
          }
        }
      }
      
      isActive() {
        return !this.impacted || this.fireDuration > 0;
      }
    }

    function useSpecial(player) {
      const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
      
      switch(selectedSpecial) {
        case "explosive":
          explosions.push(new Explosion(player.x, player.y, 180)); // Aumentado em 20% (150 -> 180)
          sounds.explosion.play();
          
          [...enemies, ...bosses].forEach(e => {
            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            if (dist < 180) {
              e.takeDamage(90 + (dist < 90 ? 40 : 0));
              
              const knockbackAngle = Math.atan2(e.y - player.y, e.x - player.x);
              const knockbackPower = 10 * (1 - dist / 180);
              e.x += Math.cos(knockbackAngle) * knockbackPower;
              e.y += Math.sin(knockbackAngle) * knockbackPower;
            }
          });
          break;
          
        case "multi":
          sounds.shoot.play();
          for (let i = -7; i <= 7; i++) {
            arrows.push(new Arrow(player.x, player.y, angle + i * 0.1));
          }
          break;
          
        case "freeze":
          sounds.freeze.play();
          enemies.forEach(e => {
            e.speed *= 0.1;
            e.slowTimer = 300; 
          });
          bosses.forEach(b => {
            b.speed *= 0.3;
            b.slowTimer = 180; 
          });
          freezeEffects.push(new FreezeEffect(player.x, player.y));
          break;
          
        case "lightning":
          sounds.lightning.play();
          const lightningTargets = [...enemies, ...bosses].filter(e => 
            Math.hypot(player.x - e.x, player.y - e.y) < 250
          ).sort((a, b) => 
            Math.hypot(player.x - a.x, player.y - a.y) - Math.hypot(player.x - b.x, player.y - b.y)
          ).slice(0, 12); // Aumentado para 12 inimigos
          
          if (lightningTargets.length > 0) {
            lightningEffects.push(new LightningEffect(player, lightningTargets));
            
            lightningTargets.forEach((target, i) => {
              target.takeDamage(75 / (i + 1));
              target.stun(30); // Paralisado por 0.5 segundos (30 frames)
              if (target.type === 5 || target.type === 6 || target.type === 7 || target.type === 8) {
                target.shootCooldown += 90; 
              }
            });
          }
          break;
          
        case "shield":
          sounds.shield.play();
          player.shieldActive = true;
          player.shieldTimer = 360; 
          break;
          
        case "meteor":
          sounds.meteor.play();
         
          
          setTimeout(() => {
            if (enemies.length > 0 || bosses.length > 0) {
              const target = enemies[0] || bosses[0];
              meteors.push(new Meteor(target.x, target.y));
            }
          }, 0);
          
          setTimeout(() => {
            if (enemies.length > 1 || bosses.length > 0) {
              const target = enemies[1] || bosses[0];
              meteors.push(new Meteor(target.x, target.y));
            }
          }, 500);
          
          setTimeout(() => {
            if (enemies.length > 2 || bosses.length > 0) {
              const target = enemies[2] || bosses[0];
              meteors.push(new Meteor(target.x, target.y));
            }
          }, 1000);
          
           
          setTimeout(() => {
            if (enemies.length > 3 || bosses.length > 0) {
              const target = enemies[3] || bosses[0];
              meteors.push(new Meteor(target.x, target.y));
            }
          }, 1500);
          
           
          setTimeout(() => {
            if (enemies.length > 4 || bosses.length > 0) {
              const target = enemies[4] || bosses[0];
              meteors.push(new Meteor(target.x, target.y));
            }
          }, 2000);
          
           
          setTimeout(() => {
            if (enemies.length > 5 || bosses.length > 0) {
              const target = enemies[5] || bosses[0];
              meteors.push(new Meteor(target.x, target.y));
            }
          }, 2500);
          
           
          setTimeout(() => {
            if (enemies.length > 6 || bosses.length > 0) {
              const target = enemies[6] || bosses[0];
              meteors.push(new Meteor(target.x, target.y));
            }
          }, 3000);
          
           
          setTimeout(() => {
            if (enemies.length > 7 || bosses.length > 0) {
              const target = enemies[7] || bosses[0];
              meteors.push(new Meteor(target.x, target.y));
            }
          }, 3500);
          break;
      }
    }

    class Explosion {
      constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.maxRadius = radius;
        this.lifetime = 30;
      }
      
      update() {
        this.lifetime--;
        this.radius = this.maxRadius * (this.lifetime / 30);
      }
      
      draw() {
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
        gradient.addColorStop(0.8, 'rgba(255, 50, 0, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    class FreezeEffect {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 500;
        this.lifetime = 60;
      }
      
      update() {
        this.lifetime--;
      }
      
      draw() {
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, 'rgba(0, 200, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(0, 100, 255, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * this.radius;
          const size = Math.random() * 10 + 5;
          
          ctx.save();
          ctx.translate(
            this.x + Math.cos(angle) * dist,
            this.y + Math.sin(angle) * dist
          );
          ctx.rotate(Math.random() * Math.PI * 2);
          
          ctx.fillStyle = 'rgba(200, 240, 255, 0.8)';
          ctx.beginPath();
          ctx.moveTo(0, -size/2);
          ctx.lineTo(size/3, 0);
          ctx.lineTo(0, size/2);
          ctx.lineTo(-size/3, 0);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }
      }
    }

    class LightningEffect {
      constructor(source, targets) {
        this.source = source;
        this.targets = targets;
        this.lifetime = 20;
      }
      
      draw() {
        if (this.lifetime <= 0) return;
        this.lifetime--;
        
        ctx.strokeStyle = `rgba(0, 200, 255, ${this.lifetime / 15})`;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'cyan';
        
        let lastX = this.source.x;
        let lastY = this.source.y;
        
        for (const target of this.targets) {
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          
          const steps = 8;
          const dx = (target.x - lastX) / steps;
          const dy = (target.y - lastY) / steps;
          
          for (let i = 1; i <= steps; i++) {
            const x = lastX + dx * i + (Math.random() * 20 - 10);
            const y = lastY + dy * i + (Math.random() * 20 - 10);
            ctx.lineTo(x, y);
          }
          
          ctx.stroke();
          lastX = target.x;
          lastY = target.y;
        }
        
        ctx.shadowBlur = 0;
      }
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(20, 20, 250, 35);
      ctx.fillStyle = player.health > 50 ? "#00ff88" : player.health > 20 ? "orange" : "red";
      ctx.fillRect(20, 20, 250 * (player.health / player.maxHealth), 35);
      ctx.strokeStyle = "white";
      ctx.strokeRect(20, 20, 250, 35);
      ctx.fillStyle = "white";
      ctx.font = "16px 'Press Start 2P', cursive";
      ctx.fillText(`VIDA: ${Math.floor(player.health)}/${player.maxHealth}`, 30, 45);
      
      // Draw cooldown for current special
      let cooldownMax = 0;
      let cooldownCurrent = 0;
      let cooldownWidth = 0;
      
      switch(selectedSpecial) {
        case 'explosive': 
          cooldownMax = 600;
          cooldownCurrent = player.specialCooldowns.explosive;
          break;
        case 'multi': 
          cooldownMax = 420;
          cooldownCurrent = player.specialCooldowns.multi;
          break;
        case 'freeze': 
          cooldownMax = 780;
          cooldownCurrent = player.specialCooldowns.freeze;
          break;
        case 'lightning': 
          cooldownMax = 660;
          cooldownCurrent = player.specialCooldowns.lightning;
          break;
        case 'shield': 
          cooldownMax = 900;
          cooldownCurrent = player.specialCooldowns.shield;
          break;
        case 'meteor': 
          cooldownMax = 1200;
          cooldownCurrent = player.specialCooldowns.meteor;
          break;
      }
      
      cooldownWidth = 250 * (1 - cooldownCurrent / cooldownMax);
      
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(20, 70, 250, 25);
      ctx.fillStyle = cooldownWidth >= 250 ? "gold" : "#00ffff";
      ctx.fillRect(20, 70, cooldownWidth, 25);
      ctx.strokeStyle = "white";
      ctx.strokeRect(20, 70, 250, 25);
      
      if (cooldownWidth >= 250) {
        ctx.fillStyle = "black";
        ctx.fillText("ESPECIAL PRONTO (E)", 30, 90);
      }
      
      ctx.fillStyle = "#00ff88";
      ctx.font = "14px 'Press Start 2P', cursive";
      let specialName = "";
      switch(selectedSpecial) {
        case "explosive": specialName = "EXPLOSIVO"; break;
        case "multi": specialName = "CHUVA DE FLECHAS"; break;
        case "freeze": specialName = "CONGELAMENTO"; break;
        case "lightning": specialName = "REL√ÇMPAGO"; break;
        case "shield": specialName = "ESCUDO C√ìSMICO"; break;
        case "meteor": specialName = "ENCOMENDA DOS C√âUS"; break;
      }
      ctx.fillText(`PODER: ${specialName}`, 20, 120);
      
      if (player.shieldActive) {
        ctx.fillStyle = "rgba(0, 200, 255, 0.8)";
        ctx.fillText(`ESCUDO: ${Math.ceil(player.shieldTimer / 60)}s`, 20, 150);
      }
      
      if (player.slowTimer > 0) {
        ctx.fillStyle = "rgba(0, 200, 255, 0.8)";
        ctx.fillText(`LENTID√ÉO: ${Math.ceil(player.slowTimer / 60)}s`, 20, 180);
      }
      
      if (player.rapidFireActive) {
        ctx.fillStyle = "rgba(0, 255, 255, 0.8)";
        ctx.fillText(`TIRO R√ÅPIDO: ${Math.ceil(player.rapidFireTimer / 60)}s`, 20, 210);
      }
      
      ctx.fillStyle = "gold";
      ctx.textAlign = "right";
      ctx.fillText(`PONTOS: ${score}`, canvas.width - 30, 40);
      ctx.fillText(`RECORDE: ${highScore}`, canvas.width - 30, 70);
      
      if (player.combo > 1) {
        const comboAlpha = player.comboTimer / 60;
        ctx.fillStyle = `rgba(255, 255, 255, ${comboAlpha})`;
        ctx.fillText(`COMBO x${player.combo}!`, canvas.width - 30, 110);
      }
      ctx.textAlign = "left";
      
      if (player.dashCooldown > 0) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.fillText(`DASH: ${Math.ceil(player.dashCooldown / 60)}s`, 20, 240);
      }
    }

    function spawnEnemiesForWave(wave) {
      const count = 5 + wave * 3;
      const bossWave = wave % 5 === 0;
      const finalBossWave = wave === 15;
      
      enemies = [];
      
      // Reset player position to center
      if (player) {
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
      }
      
      if (finalBossWave) {
        // wave 15 - boss final
        bosses.push(new Enemy(8, wave));
        waveDisplay.textContent = `WAVE: ${wave} (BOSS FINAL)`;
      } else if (bossWave) {
        if (wave === 5) {
          // Wave 5 - boss roxo
          bosses.push(new Enemy(6, wave));
          waveDisplay.textContent = `WAVE: ${wave} (BOSS)`;
        } else if (wave === 10) {
          // Wave 10 - boss amarelo
          bosses.push(new Enemy(7, wave));
          waveDisplay.textContent = `WAVE: ${wave} (BOSS DOURADO)`;
        } else {
          // spawn dos monstrao bolado
          bosses.push(new Enemy(6, wave));
          waveDisplay.textContent = `WAVE: ${wave} (BOSS)`;
        }
      } else {
        for (let i = 0; i < count; i++) {
          let type;
          const r = Math.random();
          
          if (wave < 3) {
            type = 1; 
          } else if (wave < 6) {
            type = r < 0.6 ? 1 : r < 0.85 ? 2 : 3;
          } else if (wave < 10) {
            type = r < 0.4 ? 1 : r < 0.7 ? 2 : r < 0.85 ? 3 : r < 0.95 ? 4 : 5;
          } else {
            type = r < 0.3 ? 1 : r < 0.6 ? 2 : r < 0.8 ? 3 : r < 0.9 ? 4 : 5;
          }
          
          enemies.push(new Enemy(type, wave));
        }
        waveDisplay.textContent = `WAVE: ${wave}`;
      }
      
      if (Math.random() < 0.4) {
        powerUps.push(new PowerUp());
      }
    }

    function showWaveStart(wave) {
      const waveText = wave === 15 ? "BOSS FINAL" : 
                      wave === 10 ? "BOSS DOURADO" : 
                      wave === 5 ? "BOSS" : 
                      `WAVE ${wave}`;
      
      // Dark overlay
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Wave box
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(canvas.width / 2 - 200, canvas.height / 2 - 80, 400, 160);
      ctx.strokeStyle = "#00ff88";
      ctx.lineWidth = 5;
      ctx.strokeRect(canvas.width / 2 - 200, canvas.height / 2 - 80, 400, 160);
      
      // Wave text
      ctx.fillStyle = "#00ffff";
      ctx.font = "48px 'Bangers', cursive";
      ctx.textAlign = "center";
      ctx.fillText(waveText, canvas.width / 2, canvas.height / 2 - 20);
      
      ctx.font = "24px 'Press Start 2P', cursive";
      ctx.fillText("PREPARE-SE!", canvas.width / 2, canvas.height / 2 + 30);
      
      if (waveTimer < 180 && waveTimer > 0) {
        const count = Math.ceil(waveTimer / 60);
        ctx.font = "36px 'Press Start 2P', cursive";
        ctx.fillStyle = "gold";
        ctx.fillText(count.toString(), canvas.width / 2, canvas.height / 2 + 80);
      }
      
      ctx.textAlign = "start";
    }

    let player, arrows, enemies, bosses, powerUps, enemyProjectiles;
    let explosions, freezeEffects, lightningEffects, meteors;
    let currentWave, waveTimer, gameOver;

    function init() {
      player = new Player();
      arrows = [];
      enemies = [];
      bosses = [];
      powerUps = [];
      enemyProjectiles = [];
      explosions = [];
      freezeEffects = [];
      lightningEffects = [];
      meteors = [];
      
      currentWave = 1;
      waveTimer = 180; 
      gameOver = false;
      
      spawnEnemiesForWave(currentWave);
      requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
      if (!gameActive) return;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = "white";
      for (let i = 0; i < 150; i++) {
        const alpha = Math.random() * 0.8 + 0.2;
        const size = Math.random() * 3 + 1;
        ctx.globalAlpha = alpha;
        ctx.fillRect(
          Math.random() * canvas.width,
          Math.random() * canvas.height,
          size, size
        );
      }
      ctx.globalAlpha = 1;

      if (player.health <= 0) {
        gameOver = true;
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = "red";
        ctx.font = "72px 'Bangers', cursive";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 50);
        
        ctx.font = "24px 'Press Start 2P', cursive";
        ctx.fillStyle = "white";
        ctx.fillText(`VOC√ä CHEGOU AT√â A WAVE ${currentWave}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText(`PONTUA√á√ÉO: ${score}`, canvas.width / 2, canvas.height / 2 + 60);
        
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('highScore', highScore);
          ctx.fillStyle = "gold";
          ctx.fillText("NOVO RECORDE!", canvas.width / 2, canvas.height / 2 + 100);
        }
        
        ctx.fillStyle = "#00ff88";
        ctx.fillText("CLIQUE PARA VOLTAR AO MENU", canvas.width / 2, canvas.height / 2 + 150);
        ctx.textAlign = "start";
        
        sounds.gameOver.play();
        canvas.addEventListener('click', backToMenu, { once: true });
        return;
      }

      if (waveTimer > 0) {
        waveTimer--;
        showWaveStart(currentWave);
        
        requestAnimationFrame(gameLoop);
        return;
      }

      player.update();
      player.draw();

      arrows = arrows.filter(a => a.alive);
      arrows.forEach(a => { a.update(); a.draw(); });

      enemies.forEach(e => {
        e.update();
        e.draw();
        
        if (Math.hypot(player.x - e.x, player.y - e.y) < player.radius + e.radius) {
          player.takeDamage(e.damage);
        }
      });

      bosses.forEach(b => {
        b.update();
        b.draw();
        
        if (Math.hypot(player.x - b.x, player.y - b.y) < player.radius + b.radius) {
          player.takeDamage(b.damage);
        }
      });

      enemyProjectiles = enemyProjectiles.filter(p => p.alive);
      enemyProjectiles.forEach(p => {
        p.update();
        p.draw();
        
        if (Math.hypot(player.x - p.x, player.y - p.y) < player.radius + p.radius) {
          player.takeDamage(p.damage);
          if (p.isEnergyBall) {
            player.slowTimer = 90; 
          }
          p.alive = false;
        }
      });

      powerUps = powerUps.filter(p => p.lifetime > 0);
      powerUps.forEach((p, i) => {
        p.draw();
        
        if (Math.hypot(player.x - p.x, player.y - p.y) < player.radius + p.radius) {
          sounds.powerup.play();
          switch(p.type) {
            case "heal":
              player.health = Math.min(player.maxHealth, player.health + 40);
              break;
            case "rapid":
              player.rapidFireActive = true;
              player.rapidFireTimer = 240; // 4 segundos
              break;
            case "special":
              for (const key in player.specialCooldowns) {
                player.specialCooldowns[key] = Math.max(0, player.specialCooldowns[key] - 150);
              }
              break;
            case "shield":
              player.shieldActive = true;
              player.shieldTimer = 180; 
              break;
            case "maxhp":
              player.maxHealth += 15;
              player.health += 15;
              break;
          }
          powerUps.splice(i, 1);
        }
      });

      // Update and draw meteors
      meteors = meteors.filter(m => m.isActive());
      meteors.forEach(m => {
        m.update();
        m.draw();
      });

      arrows.forEach(a => {
        enemies.forEach((e, ei) => {
          if (Math.hypot(a.x - e.x, a.y - e.y) < e.radius) {
            e.takeDamage(a.damage);
            
            score += e.scoreValue * (1 + player.combo * 0.1);
            
            if (e.health <= 0) {
              player.kills++;
              if (Math.random() < 0.05) {
                powerUps.push(new PowerUp());
              }
            }
            
            if (a.pierce <= 0) {
              a.alive = false;
            } else {
              a.pierce--;
            }
          }
        });
        
        bosses.forEach(b => {
          if (Math.hypot(a.x - b.x, a.y - b.y) < b.radius) {
            b.takeDamage(a.damage * 0.6); 
            
            if (b.health <= 0) {
              score += b.scoreValue * (1 + player.combo * 0.2);
            }
            
            if (a.pierce <= 0) {
              a.alive = false;
            } else {
              a.pierce--;
            }
          }
        });
      });

      enemies = enemies.filter(e => e.health > 0);
      bosses = bosses.filter(b => b.health > 0);

      explosions = explosions.filter(e => e.lifetime > 0);
      explosions.forEach(e => { e.update(); e.draw(); });
      
      freezeEffects = freezeEffects.filter(f => f.lifetime > 0);
      freezeEffects.forEach(f => { f.update(); f.draw(); });
      
      lightningEffects = lightningEffects.filter(l => l.lifetime > 0);
      lightningEffects.forEach(l => l.draw());

      if (enemies.length === 0 && bosses.length === 0 && waveTimer <= 0) {
        currentWave++;
        
        if (currentWave > 15) {
          victoryScreen.style.display = 'flex';
          sounds.victory.play();
          
          if (score > highScore) {
            highScore = score;
            localStorage.setItem('highScore', highScore);
          }
          return;
        }
        
        waveTimer = 180; 
        spawnEnemiesForWave(currentWave);
      }

      drawHUD();
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
